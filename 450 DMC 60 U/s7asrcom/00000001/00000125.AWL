FUNCTION "FC_ACHSE_HILF" : VOID
TITLE =
//$Revision: 1.31 $
//$Date: 2008/11/06 06:28:19CET $
//$Author: schmoelp $
//
//
//Funktionsbeschreibung:
//
//    Abfrage: Achse vorhanden ? 
//    Aktivierung Meßsystem
//    Vorschubkorrekturschalter / Eilgang-Überlagerung aktivieren 
//
//    Achse: Nachführbetrieb 
//    Umschaltung OVR für Eilgang
//    Achse: "Bremse lösen" Übergabe-Signal bilden
//    Verzögerung bilden: Reglerfreigabe nach Bremse lüften
//    
//    Achse: Impulsfreigabe
//    Achse: Bremse lösen Verzögerung bilden 
//    Achse: Reglerfreigabe
//
//
//Achs Typ:
//    1 = Teilungsachse
//    2 = Positionierachse
//
//    Achse: Fehlermeldung //VS-SP-X,Reglersperre
//    Achse: //NC-Schnittstelle: Reglersperre
//    Achse: Servomodul-Überwachung  //NOT-AUS,Antrieb nicht bereit
//    Achse: Temperatur-Überwachung  //VS-SP-X,Motortemperatur zu hoch
//
//Logbuch:
///V1.0 /23-05-00/ AB Schnittstellen geändert
//
//
///V0.11/8-Mai-00/ BAG
// o Eilgang-Überlagerung in Jog mit Eilgang-Override veränderbar aktiviert
//
///V0.10/23-02-00/ BAG
// o Schnittstelle erweitert: => Vorschubfreigabe für Antriebsoptimierungs-Tests 
//    E_Taste_Brems_Auf_Messen  // für Antriebsoptimierungs-Tests 
//
///V0.9/17-02-00/ BAG
// o Schnittstelle erweitert: E_Kanal1_E_Transform => Vorschubfreigabe
//
///V0.8/15.12.99/ BAG
//- NST "Achsen_Halt_von_aussen" ergänzt
//- Vorschubkorrekturschalter / Eilgang-Überlagerung aktivieren 
//- Achse: Nachführbetrieb 
//
//V0.6 /22.10.99/ BAG
//- Modul Schnittstelle eingerichtet 
//
//22.12.99 / AB
//Fehler mit Quittiertaste rückgesetzt 
AUTHOR : BAG
FAMILY : DM_Basis
NAME : ACHSEN
VERSION : 0.10


VAR_INPUT
  EX_EN : BOOL ;	//Modul-Freigabe
  EX_UDHex_00_IB_Bit_Achse : BOOL ;	//PLC_MD_Achsen-Abwahl 1.Achse: 0=ein, 1=aus
  EX_UDHex_01_Ax_Messystem : BOOL ;	//PLC_MD_Anwahl Messystem 1.Achse: 0=indirekt, 1=direkt
  EX_UDHex_RPF_Richtung : BOOL ;	//PLC MD Anfahrrichtung Referenzieren
  EX_Option_Safety : BOOL ;	//Maschine mit Safety 
  EX_Safe_Bremsentest : BOOL ;	//Bremsentest von Safety Integrated
  EX_Safe_StopC_aktiv : BOOL ;	//Stop C aktiv --> Bremse oeffnen
  EX_Safe_StopA_aktiv : BOOL ;	//Stop A aktiv
  EX_Safe_Teststop_laeuft : BOOL ;	//Teststop läuft
  EX_Maschine_Ein : BOOL ;	//Antrieb Ein bei Maschine Ein
  EX_Antrieb_Sperre : BOOL ;	//Antrieb gesperrt
  EX_Freigabe_Regler : BOOL ;	//Freigabe Regler
  EX_Leistung_steht_an : BOOL ;	//Leistung steht an in Betriebsarten
  EX_VSHalt_EinzelAchse : BOOL ;	//Achs-Vorschubsperre von aussen angefordert
  EX_VSHalt_Gruppe : BOOL ;	//Vorschub Halt Hauptachsen
  EX_VSHalt_Kanal : BOOL ;	//Vorschub Halt Kanal
  EX_RefPkt_Achse : BOOL ;	//Referenzpunkt Achse (Referenzpunktnocke)
  EX_Abbruch_Positionieren : BOOL ;	//Abbruch Positionieren
  EX_Ax_KorrWirksam_1x7 : BOOL ;	//Anforderung Vorschub Korrektur wirksam setzen
  EX_Ax_E_RefSyn1_60x4 : BOOL ;	//Achse Referiert
  EX_Ax_E_FahrAF_61x0 : BOOL ;	//Fahranforderung für Antriebsoptimierungs-Tests 
  EX_Ax_E_Steht_61x4 : BOOL ;	//Achse Steht
  EX_Ax_E_LageRegler_61x5 : BOOL ;	//Lageregler aktiv
  EX_Ax_E_DrehzRegler_61x6 : BOOL ;	//Drehzahlregler aktiv
  EX_Ax_E_StromRegler_61x7 : BOOL ;	//Stromregler aktiv
  EX_Ax_E_PLC_Achse_63x1 : BOOL ;	//Achse ist PLC Achse
  EX_Ax_E_FBMinus_64x6 : BOOL ;	//Fahrbefehl Minus
  EX_Ax_E_FBPlus_64x7 : BOOL ;	//Fahrbefehl Plus
  EX_Ax_E_ChPoss_68x5 : BOOL ;	//Achstausch möglich
  EX_Ax_E_NeutrASp_68x6 : BOOL ;	//Neutrale Achse
  EX_Ax_E_MotOK_93x5 : BOOL ;	//Achse Drive-Ready
  EX_Ax_E_IntSperr_93x6 : BOOL ;	//Integrator-Drehzahlregler gesperrt
  EX_Ax_E_ImpFrei_93x7 : BOOL ;	//Impulse freigegeben
  EX_Ax_E_MTempWarn_94x0 : BOOL ;	//Temperaturvorwarnung Motor
  EX_Ax_E_KTempWarn_94x1 : BOOL ;	//Temperaturvorwarnung Kühlkörper
  EX_FahrAnf_Positiv : BOOL ;	//Fahranforderung Positiv
  EX_FahrAnf_Negativ : BOOL ;	//Fahranforderung Negativ
  EX_Inch_Umrechnen : BOOL ;	//Anforderung zur Inch-Umrechnung
  EB_Achs_Typ : BYTE ;	//Achstyp:1=Teilungsachse Modulo,2=Positionierachse Modulo,3=Positionierchse lin
  EB_MSST_Vorschub_OVR : BYTE ;	//MSST: Vorschub Override
  EB_Positierung : BYTE ;	//Art der Positionierung: 0=Abs.,1=Ink,2=kürz.Weg,3=Pos.Plus,4=Pos.Minus
  EI_Teilung : INT ;	//Teilung bei Teilungsachse
  EI_Achs_Nr : INT ;	//Achs Nummer
  ER_SollPosition : REAL ;	//Anforderung für Sollposition:
  ER_Istposition : REAL ;	//Isposition der Hilfsachse
  ER_Geschwindigkeit : REAL ;	//Vorgabe Geschwindigkeit
  ET_Timer_Ax_Freigabe : TIMER ;	//Timer Achs-Freigabe
END_VAR
VAR_IN_OUT
  EAX_Ax_Anforderung_Pos : BOOL ;	//Anforderung Fahren der Achse
  EAX_Ax_Rueckmeldung_Pos : BOOL ;	//Rückmeldung der Fahranforderung
  EAX_Ax_Fehler_Pos : BOOL ;	//Fehler bei Positionierung
  EAX_Ax_Anf_Referenzieren : BOOL ;	//Anforderung Referenzieren
  EAX_Ax_A_ASpSperre_1x3 : BOOL ;	//Achsen-/Spindelsperre
  EAX_Ax_A_NachfBetr_1x4 : BOOL ;	//Nachführbetrieb
  EAX_Ax_A_LageMess1_1x5 : BOOL ;	//Lagemeßsystem 1
  EAX_Ax_A_LageMess2_1x6 : BOOL ;	//Lagemeßsystem 2
  EAX_Ax_A_KorrW_1x7 : BOOL ;	//Korrektur wirksam
  EAX_Ax_A_ReglerFrei_2x1 : BOOL ;	//Reglerfreigabe
  EAX_Ax_A_RestWegRe_2x2 : BOOL ;	//Restweg löschen
  EAX_Ax_A_VSSpHalt_4x3 : BOOL ;	//Vorschub/Spindel-Halt
  EAX_Ax_A_Minus_4x6 : BOOL ;	//Fahrbefehl Minus
  EAX_Ax_A_Plus_4x7 : BOOL ;	//Fahrbefehl Plus
  EAX_Ax_A_NCASpChA_8x0 : BOOL ;	//Kanal A zuordnen
  EAX_Ax_A_NCASpStrobe_8x4 : BOOL ;	//Strobe 
  EAX_Ax_A_PLCASp_8x7 : BOOL ;	//PLCAchse
  EAX_Ax_A_RefVerzoeg_12x7 : BOOL ;	//Referenzverzögerung bei Motormessystem
  EAX_Ax_A_ImpFrei_21x7 : BOOL ;	//Impulsfreigabe
  EAX_Ax_A_PLC_Achse_28x7 : BOOL ;	//PLC Kontrolliert die Achse
  EAX_AX_RefSync1 : BOOL ;	//Achse referiert
  EAX_Alarm_Regler : BOOL ;	//Alarm Reglerfreigabe fehlt
  EAX_Alarm_VSSP_Mot_Temp : BOOL ;	//Alarm Motortemperatur zu hoch
  EAX_Alarm_VSSP_KK_Temp : BOOL ;	//Alarm Kühlkörpertemperatur zu hoch
  EAX_Alarm_NA_MotOK : BOOL ;	//Alarm Achse nicht bereit
  EAX_Alarm_FehlerPos : BOOL ;	//Alarm Fehler bei Positionierung
  EAX_M_Bremse_oeffnen : BOOL ;	//Ausgang Bremse lüften
  EAX_Anf_Lesen_AxPos : BOOL ;	//Anforderung Lesen der AchsPosition
  EAX_Rdy_Lesen_AxPos : BOOL ;	//Rückmeldung Lesen der AchsPosition
  EAX_Achse_Fahranf : BOOL ;	//Achse Fahren (FC18 Start)
  EAX_Achse_InPosition : BOOL ;	//Achse in Position (Rückmeldung von FC18)
  EAX_Achse_Fehler_Pos : BOOL ;	//Fehler bei Positionierung (Rückmeldung von FC18)
  EAX_Achse_Positioniert : BOOL ;	//Achse ist beim Fahren
  EAX_InPos_Merker : BOOL ;	
  EAB_Ax_VS_Korrektur_DBB0 : BYTE ;	//Vorschub Korrektur
  EAB_SKZ_Achse : BYTE ;	//Schrittkette Achse
END_VAR
VAR_TEMP
  TB_AchsTyp : BYTE ;	//Achs Typ
  TB_AchsNr : INT ;	//Achs Nr
  TB_AchsFehlerNr : BYTE ;	//Fehler Nr.
  TR_Grad : REAL ;	
  TR_IstPos : REAL ;	
  TR_Chk_Pos : REAL ;	
  PosAchse_modulo : BOOL ;	
  PosAchse_linear : BOOL ;	
  Teilungsachse : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =Modul-Freigabe

      UN    #EX_EN; 
      BEB   ; 
NETWORK
TITLE =Fehler quittieren

      U     "M_Ruecksetze_Fehler"; 
      R     #EAX_Alarm_NA_MotOK; 
      R     #EAX_Alarm_Regler; 
      R     #EAX_Alarm_VSSP_Mot_Temp; 
      R     #EAX_Alarm_VSSP_KK_Temp; 
NETWORK
TITLE =Achstyp Teilungsachse

      L     #EB_Achs_Typ; // Abfrage Achstyp
      L     1; // Teilungsachse 
      ==I   ; 
      =     #Teilungsachse; 
NETWORK
TITLE =Achstyp Positionierachse modulo 

      L     #EB_Achs_Typ; // Abfrage Achstyp
      L     2; // Positionierachse modulo 
      ==I   ; 
      =     #PosAchse_modulo; 
NETWORK
TITLE =Achstyp Positionierachse nicht modulo

      L     #EB_Achs_Typ; // Abfrage Achstyp
      L     3; // Positionierachse nicht modulo 
      ==I   ; 
      =     #PosAchse_linear; 
NETWORK
TITLE =Alarm: Achse nicht bereit

      U     #EX_Leistung_steht_an; 
      UN    #EX_Antrieb_Sperre; 
      UN    #EX_UDHex_00_IB_Bit_Achse; 
      UN    #EX_Safe_StopA_aktiv; 
      UN    #EX_Safe_Teststop_laeuft; 
      U(    ; 
      O     #EAX_Ax_A_LageMess1_1x5; 
      O     #EAX_Ax_A_LageMess2_1x6; 
      )     ; 
      UN    #EX_Ax_E_MotOK_93x5; 
      S     #EAX_Alarm_NA_MotOK; 
NETWORK
TITLE =Alarm Reglerfreigabe fehlt

      U     #EX_Leistung_steht_an; // Antriebe ein
      UN    #EX_Antrieb_Sperre; // keine Antriebssperre
      UN    #EX_UDHex_00_IB_Bit_Achse; // Achse ausblenden
      U     #EAX_Ax_A_ReglerFrei_2x1; // und Achse ist ein
      UN    #EX_Ax_E_FahrAF_61x0; // und keine Achseoptimierung
      U(    ; 
      ON    #EX_Ax_E_LageRegler_61x5; // Keine Reglerfreigabe
      ON    #EX_Ax_E_DrehzRegler_61x6; // Keine Impulsfreigabe
      ON    #EX_Ax_E_ImpFrei_93x7; // DBX93.7 Impulse freigegeben
      )     ; 
      U(    ; 
      O     #EX_Ax_E_FBMinus_64x6; // DBX64.6 Minus-Fahrbefehl 
      O     #EX_Ax_E_FBPlus_64x7; // DBX64.7 Plus-Fahrbefehl 
      )     ; 
      S     #EAX_Alarm_Regler; 
NETWORK
TITLE =Alarm: Motortemperatur zu hoch / Kühlkörpertemperatur zu hoch

      U     #EX_Leistung_steht_an; // Antriebe EIN
      U(    ; 
      O     #EX_Ax_E_FBMinus_64x6; // DBX64.6 Minus-Fahrbefehl 
      O     #EX_Ax_E_FBPlus_64x7; // DBX64.7 Plus-Fahrbefehl 
      )     ; 
      =     L     19.0; 
      U     L     19.0; // Temperaturvorwarnung Kühlkörper
      U     #EX_Ax_E_MTempWarn_94x0; // Temperaturvorwarnung Motor
      S     #EAX_Alarm_VSSP_Mot_Temp; 
      U     L     19.0; // Motortemperatur zu hoch
      U     #EX_Ax_E_KTempWarn_94x1; 
      S     #EAX_Alarm_VSSP_KK_Temp; 
NETWORK
TITLE =Aktivierung Meßsystem 2
//   Direktes Messystem   
      U     #EX_UDHex_01_Ax_Messystem; // PLC_MD_Anwahl Messystem 1.Achse: 0=indirekt, 1=direkt
      UN    #EX_UDHex_00_IB_Bit_Achse; 
      =     #EAX_Ax_A_LageMess2_1x6; // Meßsystem 2 aktiv
NETWORK
TITLE =Aktivierung Meßsystem 1 Indirektes Messystem     (Default)

      UN    #EX_UDHex_01_Ax_Messystem; // PLC_MD_Anwahl Messystem 1.Achse: 0=indirekt, 1=direkt
      UN    #EX_UDHex_00_IB_Bit_Achse; 
      =     #EAX_Ax_A_LageMess1_1x5; // Meßsystem 1 aktiv
NETWORK
TITLE =Nachführbetrieb
//
// Nachführbetrieb 
//
      ON    #EX_Freigabe_Regler; // oder keine Freigabe Regler
      O     #EX_UDHex_00_IB_Bit_Achse; // Achse ausblenden (IB-Bit)             
      =     #EAX_Ax_A_ASpSperre_1x3; // Achsensperre
      =     #EAX_Ax_A_NachfBetr_1x4; // Nachführbetrieb

NETWORK
TITLE =Referenzpunktverzögerung
//
//
//
      U     #EX_RefPkt_Achse; 
      =     #EAX_Ax_A_RefVerzoeg_12x7; 

NETWORK
TITLE =Vorschubkorrekturschalter / Eilgang-Überlagerung aktivieren 
//
//Achsen-Korrektur auf Anforderung setzen
//
// Funktioniert noch nicht richtig
// 
//      SET   ; 
//      =     #EAX_Ax_A_KorrW_1x7; 
      U     #EX_Ax_KorrWirksam_1x7; 
      =     #EAX_Ax_A_KorrW_1x7; 
      SPBN  VS; 

      L     #EB_MSST_Vorschub_OVR; 
      L     B#16#3F; 
      UW    ; 
      T     #EAB_Ax_VS_Korrektur_DBB0; 
      SPA   VSE; 

VS:   L     21; 
      T     #EAB_Ax_VS_Korrektur_DBB0; 

VSE:  NOP   0; 
NETWORK
TITLE =Restweg löschen

      U     #EX_Abbruch_Positionieren; // oder Abbruch positionieren
      =     #EAX_Ax_A_RestWegRe_2x2; 


NETWORK
TITLE = Übergabe Achse referiert

      U     #EX_Ax_E_RefSyn1_60x4; // Übergabe Achse referiert
      =     #EAX_AX_RefSync1; 

NETWORK
TITLE =Impulsfreigabe

      O     #EAX_Ax_A_ReglerFrei_2x1; // Reglerfreigabe 
      O     #EX_Option_Safety; 
      =     #EAX_Ax_A_ImpFrei_21x7; // Impulsfreigabe setzen 
NETWORK
TITLE =Reglerfreigabe DBX 2.1

      U     #EX_Maschine_Ein; // Maschine EIN
      UN    #EX_Antrieb_Sperre; // Keine Sperre vom Familien Modul
      U     #EX_Freigabe_Regler; // und freigabe Regler (Klemmung)
      UN    #EX_UDHex_00_IB_Bit_Achse; // Achse ausblenden (IB-Bit) = 0
      U     #EX_Leistung_steht_an; // Leistung steht an
      UN    #EX_Option_Safety; // Sobald Safey vorhanden immer Reglerfreigabe schalten
      O     ; 
      U     #EX_Option_Safety; // Sobald Safey vorhanden immer Reglerfreigabe schalten
      UN    #EX_Safe_Bremsentest; 
      U     #EX_Freigabe_Regler; // und freigabe Regler (Klemmung)
      =     #EAX_Ax_A_ReglerFrei_2x1; 
// Reglerfreigabe 

NETWORK
TITLE =Achse: "Bremse lösen" Übergabe-Signal bilden
//Übergabe-Merker "Bremsen öffen", werden im Aufruf-Modul maschinenspezifisch 
//zusammengefasst und auf die entsprechenden Ausgänge geschaltet.
//
      O(    ; 
      UN    #EX_Ax_E_IntSperr_93x6; // DBX93.6 Integrator-Drehzahlregler gesperrt
      U     #EX_Ax_E_LageRegler_61x5; // DBX61.5 Lageregelung aktiv
      U     #EX_Ax_E_DrehzRegler_61x6; // DBX61.6 Drehzahlregler aktiv
      U     #EAX_Ax_A_ReglerFrei_2x1; // DBX2.1  Reglerfreigabe aktiv
      UN    #EX_Ax_E_FahrAF_61x0; // DBX 61.0 Fahranforderung Antriebstest
      )     ; 
      O(    ; 
      U     #EX_Ax_E_FahrAF_61x0; // DBX 61.0 Fahranforderung Antriebstest
      U     #EX_Ax_E_DrehzRegler_61x6; // DBX61.6 Drehzahlregler aktiv
      )     ; 
      O(    ; 
      U     #EX_Safe_StopC_aktiv; 
      U     #EX_Ax_E_DrehzRegler_61x6; // DBX61.6 Drehzahlregler aktiv
      U     #EX_Option_Safety; // Sobald Safey vorhanden immer Reglerfreigabe schalten
      )     ; 
      U     #EX_Ax_E_MotOK_93x5; // DBX93.5 Drive ready
      U     #EX_Leistung_steht_an; // Achsen stehen nach Anforderung Tür auf
      U     #EX_Ax_E_ImpFrei_93x7; // DBX93.7 Impulse freigegeben
      U     #EX_Ax_E_StromRegler_61x7; // DBX61.7 Stromregler aktiv
      =     #EAX_M_Bremse_oeffnen; 



NETWORK
TITLE =Timer Achsfreigabe

      U     #EAX_M_Bremse_oeffnen; 
      L     S5T#500MS; 
      SE    #ET_Timer_Ax_Freigabe; 
      NOP   0; 
      NOP   0; 
      NOP   0; 
      NOP   0; 
NETWORK
TITLE =Achse: Vorschub Halt  DBX 4.3

      ON    #EAX_Ax_A_ReglerFrei_2x1; // "Achse".A_ReglerFrei   
      ON    #ET_Timer_Ax_Freigabe; // 500ms nach Bremse auf
      O     #EX_VSHalt_EinzelAchse; 
      O     #EX_VSHalt_Gruppe; 
      O     #EX_VSHalt_Kanal; 
      =     #EAX_Ax_A_VSSpHalt_4x3; // "Achse".A_VSSpHalt 

NETWORK
TITLE =Reset Fehler bei Positionierung

      U     "M_Ruecksetze_Fehler"; 
      R     #EAX_Alarm_FehlerPos; 
      R     #EAX_Ax_Fehler_Pos; 
NETWORK
TITLE =Achse von PLC fahren Schrittkette
//    
      U     "M_Reset_Taste"; // nur in BAG Ref
      U(    ; 
      O     "DB_SIEM_BAG".E_REF; 
      O     #EAX_Alarm_FehlerPos; 
      )     ; 
      O     #EAX_Ax_A_RestWegRe_2x2; 
      SPBN  SK00; 
      SET   ; 
      R     #EAX_Ax_Anforderung_Pos; 
      R     #EAX_Anf_Lesen_AxPos; 
      R     #EAX_Achse_Positioniert; 
      R     #EAX_Ax_Rueckmeldung_Pos; 
      R     #EAX_Rdy_Lesen_AxPos; 
      R     #EAX_InPos_Merker; 
      R     #EAX_Ax_A_Minus_4x6; 
      R     #EAX_Ax_A_Plus_4x7; 

// Sprung in Schritt 9 -> Reset Achse von PLC kontrolliert erst wenn Achse steht
      L     9; 
      T     #EAB_SKZ_Achse; 

// -- Schritt 0 ----------------------------------------------------------------

SK00: L     #EAB_SKZ_Achse; // Schritt 0 ?
      L     0; 
      ==I   ; 
      SPBN  SK01; // Nein => Schritt 1

// -----------------------------------------------------------------------------


// -----------------------------------------------------------------------------

      U     #EX_Ax_E_ChPoss_68x5; // Fahranforderung:
      U(    ; // Positionieren ohne Ref.-Punkt
      O     #EX_FahrAnf_Positiv; 
      O     #EX_FahrAnf_Negativ; 
      O     #EAX_Ax_Anf_Referenzieren; 
      O     #EX_Ax_E_FahrAF_61x0; 
      O(    ; 
      U     #EAX_Ax_Anforderung_Pos; 
      UN    #EX_Ax_E_RefSyn1_60x4; 
      )     ; 
      )     ; 
      U     #EX_Leistung_steht_an; 
      SPBN  E002; 

      SET   ; 
      R     #EAX_Ax_A_PLCASp_8x7; 
      S     #EAX_Ax_A_NCASpStrobe_8x4; 
      R     #EAX_Ax_A_PLC_Achse_28x7; 

      L     1; 
      T     #EAB_SKZ_Achse; 
      SPA   MEND; 

E002: U     #EAX_Ax_Anforderung_Pos; 
      U     #EX_Leistung_steht_an; 
      U     #EX_Ax_E_LageRegler_61x5; // und Reglerfreigabe
      U     #EX_Ax_E_DrehzRegler_61x6; //     Impulsfreigabe
      U     #EX_Ax_E_ImpFrei_93x7; //     Impulse freigegeben
      SPBN  MEND; 

      L     3; 
      T     #EAB_SKZ_Achse; 

      SET   ; 
      R     #EAX_Achse_InPosition; 
      R     #EAX_Achse_Fehler_Pos; 
      R     #EAX_InPos_Merker; 
      SPA   SK03; 

// -- Schritt 1 ----------------------------------------------------------------

SK01: L     #EAB_SKZ_Achse; // Schritt 1 ?
      L     1; 
      ==I   ; 
      SPBN  SK02; // Nein => Schritt 2

// -----------------------------------------------------------------------------

      U     #EX_Ax_E_PLC_Achse_63x1; 
      SPB   MEND; 

      U     #EAX_Ax_Anf_Referenzieren; 
      SPBN  FA; 

      U     #EX_UDHex_RPF_Richtung; 
      =     #EAX_Ax_A_Plus_4x7; 

      UN    #EX_UDHex_RPF_Richtung; 
      =     #EAX_Ax_A_Minus_4x6; 

      SPA   FA1; 

FA:   U     #EX_FahrAnf_Positiv; 
      =     #EAX_Ax_A_Plus_4x7; 

      U     #EX_FahrAnf_Negativ; 
      =     #EAX_Ax_A_Minus_4x6; 

FA1:  U     #EX_Ax_E_RefSyn1_60x4; 
      R     #EAX_Ax_Anf_Referenzieren; 

// -----------------------------------------------------------------------------

      U(    ; // Positionieren ohne Ref.-Punkt
      O     #EX_FahrAnf_Positiv; 
      O     #EX_FahrAnf_Negativ; 
      O     #EAX_Ax_Anf_Referenzieren; 
      O     #EX_Ax_E_FahrAF_61x0; 
      )     ; 
      SPB   MEND; 

      SET   ; 
      R     #EAX_Ax_A_Minus_4x6; 
      R     #EAX_Ax_A_Plus_4x7; 

      L     2; 
      T     #EAB_SKZ_Achse; 
      SPA   MEND; 

// -- Schritt 2 ----------------------------------------------------------------

SK02: L     #EAB_SKZ_Achse; // Schritt 2 ?
      L     2; 
      ==I   ; 
      SPBN  SK03; // Nein => Schritt 3

// -----------------------------------------------------------------------------


// -----------------------------------------------------------------------------

      O     #EX_Ax_E_FBMinus_64x6; 
      O     #EX_Ax_E_FBPlus_64x7; 
      SPB   MEND; 

      R     #EAX_Ax_A_PLC_Achse_28x7; 

      L     0; 
      T     #EAB_SKZ_Achse; 
      SPA   MEND; 

// -- Schritt 3 ----------------------------------------------------------------

SK03: L     #EAB_SKZ_Achse; // Schritt 3 ?
      L     3; 
      ==I   ; 
      U     #EX_Ax_E_ChPoss_68x5; 
      SPBN  SK04; // Nein => Schritt 4

// -----------------------------------------------------------------------------

      SET   ; 
      S     #EAX_Achse_Positioniert; // Fahrauftrag aktiv

      R     #EAX_Ax_A_NCASpChA_8x0; 
      R     #EAX_Ax_A_PLCASp_8x7; 

      S     #EAX_Ax_A_NCASpStrobe_8x4; 

// -----------------------------------------------------------------------------

      UN    #EX_Ax_E_PLC_Achse_63x1; 
      U     #EX_Ax_E_NeutrASp_68x6; 
      UN    #EAX_Achse_Fahranf; 
      SPBN  MEND; 

      SET   ; 
      S     #EAX_Ax_A_PLC_Achse_28x7; 

      L     4; 
      T     #EAB_SKZ_Achse; 
      SPA   MEND; 

// -- Schritt 4 ----------------------------------------------------------------

SK04: L     #EAB_SKZ_Achse; // Schritt 4 ?
      L     4; 
      ==I   ; 
      SPBN  SK05; // Nein => Schritt 5

// -----------------------------------------------------------------------------

      U     #EX_Ax_E_PLC_Achse_63x1; 
      SPBN  MEND; 

      SET   ; 
      S     #EAX_Achse_Fahranf; 

      L     5; 
      T     #EAB_SKZ_Achse; 
      SPA   MEND; 

// -- Schritt 5 ----------------------------------------------------------------

SK05: L     #EAB_SKZ_Achse; // Schritt 5 ?
      L     5; 
      ==I   ; 
      SPBN  SK06; // Nein => Schritt 6

// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------

      U     #EAX_InPos_Merker; 
      UN    #EAX_Achse_Fahranf; 
      U     #EX_Ax_E_Steht_61x4; 
      O     #EAX_Achse_Fehler_Pos; 
      SPBN  MEND; 

      R     #EAX_Rdy_Lesen_AxPos; 
      R     #EAX_InPos_Merker; 

      L     6; 
      T     #EAB_SKZ_Achse; 

// -- Schritt 6 ----------------------------------------------------------------

SK06: L     #EAB_SKZ_Achse; // Schritt 6 ?
      L     6; 
      ==I   ; 
      SPBN  SK07; // Nein => Schritt 7

// -----------------------------------------------------------------------------

      U     #EAX_Achse_Fehler_Pos; 
      SPB   E061; 

      SET   ; 
      S     #EAX_Anf_Lesen_AxPos; // Anforderung Lesen Position setzen

      U     #EAX_Rdy_Lesen_AxPos; // Warten auf Quittierung
      SPBN  MEND; 
      R     #EAX_Rdy_Lesen_AxPos; 

      U     #Teilungsachse; 
      SPBN  E063; 
      L     #EI_Teilung; 
      L     0; 
      <=I   ; 
      O     ; 
      TAK   ; 
      L     360; 
      >=I   ; 
      SPB   E061; 

      L     3.600000e+002; 
      L     #EI_Teilung; 
      DTR   ; 
      /R    ; 
      T     #TR_Grad; 

      L     #ER_Istposition; 
      L     0; 
      >=R   ; 
      TAK   ; 
      SPB   xx1; 
      L     3.600000e+002; 
      +R    ; 
xx1:  L     1.000000e+001; 
      *R    ; 
      RND   ; 
      L     3600; 
      MOD   ; 
      DTR   ; 
      L     1.000000e+001; 
      /R    ; 
      T     #TR_IstPos; 

// Nachkommastellen

      L     0; 
      L     #ER_Istposition; 
      ABS   ; 
      L     #TR_Grad; 
      /R    ; 
      T     #TR_Chk_Pos; 
      L     #TR_Chk_Pos; 
      TRUNC ; 
      DTR   ; 
      -R    ; 
      T     #TR_Chk_Pos; 
      L     #TR_Chk_Pos; 
      L     1.000000e-001; 
      >R    ; 
      TAK   ; 
      U(    ; 
      L     9.000000e-001; 
      <R    ; 
      )     ; 
      SPB   E061; 

      L     #TR_IstPos; 
      L     #TR_Grad; 
      +R    ; 
      T     #TR_IstPos; 

      L     #TR_Grad; 
      L     #ER_SollPosition; 
      *R    ; 
      L     #TR_IstPos; 
      -R    ; 
      ABS   ; 
      L     5.000000e-001; 
      <=R   ; 
      SPB   E062; 
      SPA   E061; 
// -
// Positionskontrolle bei Positionierachse
// -

E063: NOP   0; 

      L     #ER_Istposition; 

// Falls Einheiten in Inch, dann Istposition in mm umrechnen
      U     #EX_Inch_Umrechnen; 
      SPBN  MM_D; 

      L     2.540000e+001; 
      *R    ; 
MM_D: T     #TR_IstPos; 

      U     #PosAchse_modulo; 
      SPBN  EMOD; 

      L     #TR_IstPos; 
      L     3.600000e+002; 
      >=R   ; 
      SPBN  K360; 
      -R    ; 
      T     #TR_IstPos; 

K360: L     #TR_IstPos; 
      L     3.595000e+002; 
      >=R   ; 
      SPB   E062; 

EMOD: L     #TR_IstPos; 
      L     #ER_SollPosition; 
      -R    ; 
      ABS   ; 

      L     5.000000e-001; 
      <=R   ; 
      SPB   E062; 

E061: SET   ; 
      =     #EAX_Alarm_FehlerPos; 
      =     #EAX_Ax_Fehler_Pos; 

E062: L     7; 
      T     #EAB_SKZ_Achse; 


// -- Schritt 7 ----------------------------------------------------------------

SK07: L     #EAB_SKZ_Achse; // Schritt 7 ?
      L     7; 
      ==I   ; 
      SPBN  SK08; // Nein => Schritt 8

// -----------------------------------------------------------------------------

      SET   ; 
      R     #EAX_Ax_Anforderung_Pos; 
      R     #EAX_Achse_Positioniert; 
      R     #EAX_Anf_Lesen_AxPos; 

      UN    #EAX_Alarm_FehlerPos; // Nur wenn kein Fehler ansteht Pos. quittieren
      S     #EAX_Ax_Rueckmeldung_Pos; 

// -----------------------------------------------------------------------------

      L     8; 
      T     #EAB_SKZ_Achse; 

// -- Schritt 8 ----------------------------------------------------------------

SK08: L     #EAB_SKZ_Achse; // Schritt 8 ?
      L     8; 
      ==I   ; 
      SPBN  SK09; // Nein => ENDE

// -----------------------------------------------------------------------------
      U     #EAX_Achse_InPosition; 
      SPB   MEND; 

      R     #EAX_Ax_A_PLC_Achse_28x7; 

      L     0; 
      T     #EAB_SKZ_Achse; 

// --- Ablauf ENDE -------------------------------------------------------------


// *** Schritt 9 Reset Achse von PLC kontrolliert erst wenn Achse steht ********

SK09: L     #EAB_SKZ_Achse; // Schritt 9 ?
      L     9; 
      ==I   ; 
      SPBN  MEND; // Nein => ENDE

      UN    #EX_Ax_E_FBMinus_64x6; 
      UN    #EX_Ax_E_FBPlus_64x7; 
      SPBN  MEND; 
      L     0; 
      T     #EAB_SKZ_Achse; 
      SET   ; 
      R     #EAX_Ax_A_PLC_Achse_28x7; 

// *****************************************************************************

// -----------------------------------------------------------------------------

NETWORK
TITLE =Ende Schrittkette

MEND: U     #Teilungsachse; 
      SPB   TEIL; 
      L     5; 
      SPA   ATYP; 
TEIL: L     4; 
ATYP: T     #TB_AchsTyp; 

      U     "DB_FEHLERMELDUNG".SAFE_MELD._701516_BT_5te_laeuft; 
      BEB   ; 

NETWORK
TITLE =Reset Achse Fahranforderung

      U     #EAX_Achse_InPosition; 
      O     #EAX_Achse_Fehler_Pos; 
      U     #EAX_InPos_Merker; 
      R     #EAX_Achse_Fahranf; 
NETWORK
TITLE =Achse positioniert

      O     #EAX_Achse_InPosition; 
      O     #EAX_Achse_Fehler_Pos; 
      S     #EAX_InPos_Merker; 
NETWORK
TITLE =Aufruf FC18 

      CALL "FC_SIEM_SPINCTRL" (
           Start                    := #EAX_Achse_Fahranf,
           Stop                     := FALSE,
           Funct                    := #TB_AchsTyp,
           Mode                     := #EB_Positierung,
           AxisNo                   := #EI_Achs_Nr,
           Pos                      := #ER_SollPosition,
           FRate                    := #ER_Geschwindigkeit,
           InPos                    := #EAX_Achse_InPosition,
           Error                    := #EAX_Achse_Fehler_Pos,
           State                    := #TB_AchsFehlerNr);

END_FUNCTION

