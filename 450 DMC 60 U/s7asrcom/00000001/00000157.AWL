FUNCTION_BLOCK "FB_SERVICE_AGENT"
TITLE =
//$Revision: 1.9 $
//$Date: 2008/01/24 10:52:27CET $
//$Author: rieds $
//
//Version 1.2
//30.10.2003 KOBS:
//- The Spindle-message with variable interval will only be issued 
//if the interval is greater then zero [h]. Thus the message can be blocked by 
//choosing an interval of zero.
//- Always reset of #yes and #no if the softkey 'yes'/ 'no' is pressed.
//
//Version 1.1:
//12.09.2003 JW 2000h - Message error correction
//PLC-Implement. Service Agent - Stand: 30.07.2003
AUTHOR : mogs
NAME : sv_agent
VERSION : 1.1
CODE_VERSION1


VAR_INPUT
  power_on : BOOL ;	
  program_run : BOOL ;	
  spindel_run : BOOL ;	
  Serv_agent_sign_of_life : BOOL ;	
  r4 : BOOL ;	
  r5 : BOOL ;	
  r6 : BOOL ;	
  r7 : BOOL ;	
  clear_mess_yes : BOOL ;	
  clear_mess_no : BOOL ;	
  clear_message2 : BOOL ;	
  clear_message3 : BOOL ;	
  clear_message4 : BOOL ;	
  clear_message5 : BOOL ;	
  clear_message6 : BOOL ;	
  clear_message7 : BOOL ;	
  para_spindel : INT ;	//for next message [h]
  Para_PLC_take_control : INT ;	//max. minutes between last sign of life and PLC Start control the Messages
  para_res_2 : INT ;	
  para_res_3 : INT ;	
  para_res_4 : INT ;	
  para_res_5 : INT ;	
  para_res_6 : INT ;	
  para_res_7 : INT ;	
END_VAR
VAR_OUTPUT
  out_mess_spindel : BOOL ;	//operator message every <spindel_parameter> hours 
  out_mess_spindel_2000 : BOOL ;	//operator message  + "DMG Service required"
  message_2 : BOOL ;	
  message_3 : BOOL ;	
  message_4 : BOOL ;	
  message_5 : BOOL ;	
  message_6 : BOOL ;	
  message_7 : BOOL ;	
END_VAR
VAR_IN_OUT
  res0 : BOOL ;	
  res1 : BOOL ;	
  res2 : BOOL ;	
  res3 : BOOL ;	
  res4 : BOOL ;	
  res5 : BOOL ;	
  res6 : BOOL ;	
  res7 : BOOL ;	
  io_res0 : DINT ;	
  io_res1 : DINT ;	
  io_res2 : DINT ;	
  io_res3 : DINT ;	
  io_res4 : DINT ;	
  io_res5 : DINT ;	
  io_res6 : DINT ;	
  io_res7 : DINT ;	
END_VAR
VAR
  old_hour : BYTE ;	// 
  old_minute : BYTE ;	// 
  c_power_on_min : BYTE ;	
  c_program_run_min : BYTE ;	
  c_spindel_run_min : BYTE ;	
  old_second : BYTE ;	
  c_spindel_run_sec : BYTE ;	
  act_year : BYTE ;	
  act_month : BYTE ;	
  act_day : BYTE ;	//read as String in Wizzard (so 4 will appear as 04 ..)
  act_hour : BYTE ;	
  act_min : BYTE ;	
  b11 : BYTE ;	
  b12 : BYTE ;	
  b13 : BYTE ;	
  b14 : BYTE ;	
  b15 : BYTE ;	
  service_agent_delay : INT ;	
  i1 : INT ;	
  i2 : INT ;	
  i3 : INT ;	
  i4 : INT ;	
  i5 : INT ;	
  i6 : INT ;	
  i7 : INT ;	
  i9 : INT ;	
  i10 : INT ;	
  i11 : INT ;	
  i12 : INT ;	
  i13 : INT ;	
  i14 : INT ;	
  c00_power_on : DINT ;	//couter absolut [h]
  c01_program_run : DINT ;	// 
  c02_spindel_run : DINT ;	// 
  c03 : DINT ;	
  c04 : DINT ;	
  c05 : DINT ;	
  c06 : DINT ;	
  c07 : DINT ;	
  c08 : DINT ;	
  c09 : DINT ;	
  d0 : DINT ;	
  d1 : DINT ;	
  d2 : DINT ;	
  d3 : DINT ;	
  d4 : DINT ;	
  d5 : DINT ;	
  d6 : DINT ;	
  d7 : DINT ;	
  spindel_para : BOOL ;	//DMG Service is required
  spindel_2000 : BOOL ;	
  yes : BOOL ;	
  no : BOOL ;	
  Sign_of_life : BOOL ;	//for Service-Agent
  Service_Agent_connect : BOOL ;	
  FP_p_on : BOOL ;	
  reject_message1 : BOOL ;	
  reject_message2 : BOOL ;	
  M_True : BOOL  := TRUE;	
  new_minute : BOOL ;	
  new_hour : BOOL ;	
  new_second : BOOL ;	
  b013 : BOOL ;	
  b014 : BOOL ;	
  b015 : BOOL ;	
END_VAR
VAR_TEMP
  time_date : DATE_AND_TIME ;	//do not change this local adress !!!
  act_return : INT ;	
  r1 : BOOL ;	
  r12 : BOOL ;	
  r13 : BOOL ;	
  r14 : BOOL ;	
  r15 : BOOL ;	
  r11 : BOOL ;	
  main_power_on : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =clear spindle messages with YES

      SET   ; 
      =     #main_power_on; 

      U     #clear_mess_yes; 
      R     #clear_mess_yes; 
      =     L     12.0; 
      U     L     12.0; 
      U     #spindel_2000; 
      R     #spindel_2000; 
      R     #reject_message2; 
      U     L     12.0; 
      U     #spindel_para; 
      R     #spindel_para; 
      R     #reject_message1; 
      U     L     12.0; 
      BLD   102; 
      R     #yes; 
NETWORK
TITLE =clear spindel messages with NO
//the message will reoccur after next power on
      U     #clear_mess_no; 
      R     #clear_mess_no; 
      =     L     12.0; 
      U     L     12.0; 
      U     #spindel_2000; 
      R     #spindel_2000; 
      S     #reject_message2; 
      U     L     12.0; 
      U     #spindel_para; 
      S     #reject_message1; 
      R     #spindel_para; 
      U     L     12.0; 
      BLD   102; 
      R     #no; 
NETWORK
TITLE =out spindel message variable interval

      U     #spindel_para; 
      U(    ; 
      L     #para_spindel; 
      L     0; 
      >I    ; 
      )     ; 
      =     #out_mess_spindel; 
NETWORK
TITLE =out spindel messages interval 2000 hours

      U     #spindel_2000; 
      =     #out_mess_spindel_2000; 
NETWORK
TITLE =generate message after next power on if answer was NO

      U     #main_power_on; 
      FP    #FP_p_on; 
      =     L     12.0; 
      U     L     12.0; 
      U     #reject_message1; 
      S     #spindel_para; 
      U     L     12.0; 
      U     #reject_message2; 
      S     #spindel_2000; 
NETWORK
TITLE =read system time

      CALL "READ_CLK" (
           RET_VAL                  := #act_return,
           CDT                      := #time_date);
//--------------------------------------------
// Lokal Byte 0 = year
// Lokal Byte 1 = month
// Lokal Byte 2 = day
// Lokal Byte 3 = hour
// Lokal Byte 4 = minute
// Lokal Byte 5 = second
//--------------------------------------------
//Do not change adress 0 temp "time_date"  !!!
//--------------------------------------------

      CLR   ; 
      =     #new_second; 
      =     #new_minute; 
      =     #new_hour; 
//--------------------------------------------
      L     LB     5; 
      L     #old_second; 
      ==I   ; 
      SPB   m1; 
      TAK   ; 
      T     #old_second; 
      =     #new_second; 
//--------------------------------------------

m1:   L     LB     4; 
      L     #old_minute; 
      ==I   ; 
      SPB   h1; 
      TAK   ; 
      T     #old_minute; 
      =     #new_minute; 
//--------------------------------------------

h1:   L     LB     3; 
      L     #old_hour; 
      ==I   ; 
      SPB   t1; 
      T     #old_hour; 
      =     #new_hour; 

t1:   L     LB     4; 
      BTI   ; 
      T     #act_min; 
      L     LB     3; 
      BTI   ; 
      T     #act_hour; 
      L     LB     2; 
      BTI   ; 
      T     #act_day; 
      L     LB     1; 
      BTI   ; 
      T     #act_month; 
      L     LB     0; 
      BTI   ; 
      T     #act_year; 

      UN    #new_second; 
      UN    #new_minute; 
      UN    #new_hour; 
      BEB   ; 

NETWORK
TITLE =Counter 0: power on

      U     #power_on; 
      U     #new_minute; 
      SPBN  c1; //next counter
      L     1; 
      L     #c_power_on_min; 
      +I    ; 
      T     #c_power_on_min; 
      L     60; 
      <I    ; 
      SPB   c1; //next counter
      L     0; //new cycle
      T     #c_power_on_min; 
//-----------------------------------------------
      L     #c00_power_on; 
      L     1; 
      +D    ; 
      SPS   c0_2; //overflow ?
c0_1: T     #c00_power_on; 
      SPA   c1; //next counter
c0_2: L     1; //counter newstart
      SPA   c0_1; 

NETWORK
TITLE =Counter 1: programm run

c1:   U     #program_run; 
      U     #new_minute; 
      SPBN  c2; //next counter
      L     1; 
      L     #c_program_run_min; 
      +I    ; 
      T     #c_program_run_min; 
      L     60; 
      <I    ; 
      SPB   c2; //next counter
      L     0; //new cycle
      T     #c_program_run_min; 
//-----------------------------------------------
      L     #c01_program_run; 
      L     1; 
      +D    ; 
      SPS   c1_2; //overflow ?
c1_1: T     #c01_program_run; 
      SPA   c2; //next counter
c1_2: L     1; //counter newstart
      SPA   c1_1; 
NETWORK
TITLE =Counter 2: spindel run - check <para_spindel> + 2000

c2:   U     #spindel_run; 
      U     #new_second; 
//      U     M      0.7
      SPBN  c3; //next counter
      L     1; 
      L     #c_spindel_run_sec; //sec +1
      +I    ; 
      T     #c_spindel_run_sec; 
      L     60; 
      <I    ; 
      SPB   c3; //next counter
      L     0; //new sec_cycle
      T     #c_spindel_run_sec; 
      L     1; 
      L     #c_spindel_run_min; //min + 1
      +I    ; 
      T     #c_spindel_run_min; 
      L     60; 
      <I    ; 
      SPB   c3; //next counter
      L     0; //new min_cycle
      T     #c_spindel_run_min; 
//-----------------------------------------------
      L     #c02_spindel_run; 
      L     1; //next hour
      +D    ; 
      SPS   c2_2; //overflow ?
c2_1: T     #c02_spindel_run; 
      L     #para_spindel; 
      MOD   ; 
      L     0; 
      ==D   ; 
      UN    #Service_Agent_connect; 
      S     #spindel_para; //every <para_spindel>[h]
//---------------------------------------------------
      L     #c02_spindel_run; 
      L     2000; 
      MOD   ; 
      L     0; 
      ==D   ; 
      UN    #Service_Agent_connect; 
      S     #spindel_2000; 

//----------------------------------------------------
      SPA   c3; //next counter
c2_2: L     1; //counter newstart
      SPA   c2_1; 
NETWORK
TITLE =reserve

c3:   NOP   0; 

NETWORK
TITLE =Service Agent - Sign of Life

      U     #M_True; 
      =     L     12.0; 
      U     L     12.0; 
      U     #Serv_agent_sign_of_life; 
      SPBNB _001; 
      L     0; 
      T     #service_agent_delay; 
      SET   ; 
      SAVE  ; 
      CLR   ; 
_001: U     BIE; 
      S     #Service_Agent_connect; 
      R     #Serv_agent_sign_of_life; 
      U     L     12.0; 
      U     #Service_Agent_connect; 
      U(    ; 
      L     #service_agent_delay; 
      L     #Para_PLC_take_control; 
      >=I   ; 
      )     ; 
      R     #Service_Agent_connect; 
NETWORK
TITLE =Delay PLC take control

      U     #Service_Agent_connect; 
      U     #main_power_on; 
      U     #new_minute; 
      SPBNB _002; 
      L     #service_agent_delay; 
      L     1; 
      +I    ; 
      T     #service_agent_delay; 
_002: NOP   0; 
NETWORK
TITLE =

      BEA   ; 


END_FUNCTION_BLOCK

