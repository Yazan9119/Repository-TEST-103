FUNCTION_BLOCK FB_TDC_DM

TITLE = ''
//$Revision: 1.35 $
//$Date: 2008/01/31 10:04:08CET $
//$Author: sth $

VAR_INPUT
  Start       : BOOL;
  Mode        : INT;    //0: Beladen DB137  --> DB227  
                        //1: Entladen DB227 --> DB137
                        //3: Vergleichen beim Entladen --> Lesen in DB137 und vergleichen mit Inhalt von DB227
END_VAR
VAR_IN_OUT
  Done        : BOOL;
  Error       : BOOL;
  Vergleich   : BOOL;
  State       : INT;     // 1001 := unerlaubte Stringlänge bei Wandlung BCD nach String 
END_VAR

VAR_TEMP
  // temporäre Variablen
   Anz_Item     : INT;
   j,m,n,k      : INT;
   BCD_Byte     : BYTE;
   Erg_bool     : BOOL;
   Quell_BCD    : WORD;
   temp_real    : REAL;
   Faktor       : REAL;
   temp_word    :WORD;

   index       : INT;
   ziel        : INT;
   Erg_Int     : INT;
   Erg_Byte    : BYTE;
   Erg_Real    : REAL;
   Quell_DWORD : DWORD;
   Text        : STRING[32];
   res         : INT; 
  
   AnzByte     : INT;
   Funktion    : INT;
   Bit_Nr      : INT;
   ziel_Bit_Nr : INT;
   abByte      : INT;

   text_pos    : INT; // Position im DB228
   text_227    : INT; 
   BCD_LOW     : BYTE;
   BCD_HIGH    : BYTE;
   BCD_LOW_AS  : BYTE;
   BCD_High_AS : BYTE;
   Bit_x       : BOOL;
   Anz         : INT;
   akt_laenge  : INT;
   ASZeichen   : INT;
   Wert        : INT;
   Zeichen     : CHAR;
   links,rechts: INT;
   Null_found  : BOOL;
   Bund_DM     : INT;
   WZ_DM       : DINT;
   Fuer_Nullen : INT; 
   
   erg0        : INT;
   erg1        : INT;
   erg2        : INT;
   erg3        : INT ;
   erg4        : INT;
   erg5        : INT;
   erg6        : INT;
   erg7        : INT;
   Ganzzahl    : REAL;
   Minus       : BOOL;
   Nachkommaz  : REAL;
   BCD_Word    : WORD;
   BCD_Word_a  : WORD;
   BCD_Word_b  : WORD;
   BCD_Word_c  : WORD;
   BCD_Word_d  : INT;
   BCD_Word_x  : WORD;
   BCD_Word_w  : WORD;
   BCD_Word_y  : WORD;
   BCD_Word_z  : INT;
   BCD_1Dek    : WORD;
   BCD_2Dek    : WORD;
   BCD_3Dek    : WORD;
   BCD_4Dek    : WORD;
   bcd_word1   : WORD; 
   bcd_word2   : WORD; 
   bcd_word3   : WORD; 
   bcd_word4   : WORD; 
   Faktor1     : REAL;
   Faktor2     : REAL;
   BCD_CODE    : REAL;
   Negativ     : BOOL;
   Einganswert : REAL;
   xx01        : DWORD;
   xx02        : DWORD; 
   xx03        : DWORD; 
   xx04        : DWORD; 
   
   Ganzza      : REAL;
   Dezimst     : REAL;
   y           : INT;
   x           : INT;
   Stell_1     : INT;
   Stell_2     : INT;
   REAL_WERT   : REAL;
   h01         : REAL;
   h02         : REAL;
   h03         : REAL;
   h04         : REAL;
   h05         : REAL;
   h06         : REAL;
   BCD_BYTE_a  : WORD;
   BCD_BYTE_b  : WORD;
   BCD_BYTE_1  : WORD;
   BCD_BYTE_c  : INT;
   BCD_BYTE_d  : WORD;

   BCD_DWORD_a : DWORD;
   BCD_DWORD_d : WORD;
   BCD_DWORD_c : DWORD;
   BCD_WORD_0a : WORD;
   BCD_WORD_1a : WORD;
   BCD_DWORD_11: DWORD;
   BCD_DWORD_12: DWORD;
   BCD_DWORD_13: WORD;
   BCD_DWORD_14: DWORD;
   BCD_DWORD_113: DWORD;
   BCD_DWORD_112: DWORD;
   BCD_1Byte_a: DWORD;
   BCD_1Byte_b: WORD;
   BCD_2Byte_a: DWORD;
   BCD_2Byte_b: WORD;
  
   BCD_Byte_0 : BYTE;
   BCD_LOW_0  : BYTE;
   BCD_High_0 : BYTE;
   Minus_0    : BOOL; 
   Ganzzahl_0 : REAL;
   Nachkommaz_0:REAL;
   erg0_0      : INT;
   erg1_0      : INT;
   erg2_0      : INT;
   erg3_0      : INT ;
   erg4_0      : INT;
   erg5_0      : INT;
   erg6_0      : INT;
   erg7_0      : INT;
 
   xx22        : DWORD;
   xx23        : BYTE ;
   Faktor1_0     : REAL;
   Faktor2_0     : REAL;
   BCD_CODE_0    : REAL;
   Negativ_0     : BOOL;
   Einganswert_0 : REAL;
   xx01_0        : DWORD;
   xx02_0        : DWORD; 
   Ganzza_0      : REAL;
   Dezimst_0     : REAL;
   y_0           : INT;
   x_0           : INT;
   Stell_1_0     : INT;
   Stell_2_0     : INT;
   REAL_WERT_0   : REAL;
   h01_0         : REAL;
   h02_0         : REAL;
   h03_0         : REAL;
   h04_0         : REAL;
   h05_0         : REAL;
   h06_0         : REAL;

//F20
F18_BCD1     :DWORD;
F18_BCD2     :DWORD;

//F20
BCD_F20_1    :BYTE;
BCD_F20_2    :BYTE;
BCD_F20_save :BYTE;

//F21
Pos_length: INT;
Pos_radius: INT;

//F22
Zaehler      :INT;

//F23
s,t,u,r,gl        :INT;
Vorz,Gleitp,v  :BOOL;
Merker:REAL;
String1     :STRING[12];
w,l  :INT;
F23mw1,F23mw2  :WORD;
//F90
Regal160ger  :BOOL;
//F91
q,mx,offsetLR,offsetSchn:INT;
    
END_VAR

VAR
  // statische Variablen
    i           : INT;
    HM_Start    : BOOL;
    aktiv       : BOOL;
    von         : INT;
    bis         : INT;  

END_VAR

LABEL 
  F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13,F14,F15,F16,F17,F18;F19,F20,F21,F22,F23,F24,F25,
  F88,F89,F90,F91,F92,F93,F94,F95,F96,F97,F98,F99,
  F101,F102,F103,F104,F105,F106,F107,F108,F109,F110,F111,F112,F113,F114,F115,F116,F117,F118,F119,F120,F121,F122,F123,F124,F125,
  F188,F189,F190,F191,F192,F193,F194,F195,F196,F197,F198,F199,
  M3F1,M3F2,M3F3,M3F5,M3F6,M3F15,M3F20,M3F23,a01,M3NEU,MF23end,
  FEND,BEND,TEST,MODE3,M3FEND,a02,s01,s02,a03,s05,s06,x08,x09,F23end,x10; 
END_LABEL 


// Anweisungsteil

text_pos     := 0;  // Position des Text im DB 229 Schmier-DB
text_227     :=32;
Anz_Item     := DB_KONFIG_DMTDC.AnzItem;
Anz          := DB_KONFIG_DMTDC.Anz;
Fuer_Nullen := 0;
Pos_length := DB_KONFIG_DMTDC.Tool_size.pos_length;
Pos_radius := DB_KONFIG_DMTDC.Tool_size.pos_radius;

// Flanke Start erkennen
IF Start AND (NOT HM_Start) THEN
   von := 1;
   bis := von + Anz;
   Done := False; 
   aktiv := True;
   Error:= False;
   State := 0;
ELSE
    von := bis +1;
    bis := von + Anz;
    IF bis > Anz_Item THEN
       bis := Anz_Item;   
//       Done := True;
       aktiv := False;
    END_IF;
END_IF;
HM_Start := Start; 
IF Start = False THEN
   Done := False;
   aktiv :=False;   
END_IF;

IF Done OR NOT Start THEN
    GOTO BEND;
END_IF;

IF Mode = 3 THEN
    GOTO MODE3;  // vergleichen von Name und Duplonummer
END_IF;

FOR i:=von TO bis BY 1 DO
    
    // Schnittstelle zu Konvertbaustein
    index       := db228.list[i].Item.index;
    abByte      := db228.list[i].Item.abByte;
    AnzByte     := db228.list[i].Item.AnzByte;
    Bit_Nr      := db228.list[i].Item.Bit_Nr;
    Funktion    := db228.list[i].Item.Funktion + (Mode*100);
    ziel        := db228.list[i].Item.ziel;  
    ziel_Bit_Nr := db228.list[i].Item.ziel_Bit_Nr; 
    Faktor      := db228.list[i].Item.Faktor;
    res         := db228.list[i].Item.res;

CASE Funktion OF
  //0: Beladen DB137-->:DB227
  1 : GOTO F1;  // BCD (2Byte) --> INT (2Byte)
  2 : GOTO F2;
  3 : GOTO F3;
  4 : GOTO F4;
  5 : GOTO F5;
  6 : GOTO F6;
  7 : GOTO F7;
  8 : GOTO F8;
  9 : GOTO F9;
  10 : GOTO F10;
  11 : GOTO F11;
  12 : GOTO F12;
  13 : GOTO F13;
  14 : GOTO F14;
  15 : GOTO F15;
  16 : GOTO F16;
  17 : GOTO F17;
  18 : GOTO F18;
  19 : GOTO F19;
  20 : GOTO F20;
  21 : GOTO F21;
  22 : GOTO F22;
  23 : GOTO F23;
  24 : GOTO F24;
  25 : GOTO F25;
  
  88: GOTO F88;//Bei Drehwerkzeugen die Länge1 und Länge2 vertauschen (Ruag)
  89: GOTO F89;//Auto WZ-Größen Erkennung im Standardformat-4SFD02 mit Werten aus Wizzard mit Nominalwerten
  90: GOTO F90;//Auto WZ-Größen Erkennung im Standardformat-4SFD01 mit Werten aus Wizzard
  91: GOTO F91;//Auto Schneidenanzahl Ermittlung
  92: GOTO F92;//Auto WZ-Größen Erkennung
  93: GOTO F93;//2#10110000(B0)-->Byte
  94: GOTO F94; // --> Ziel BIT  auf 1 schreiben
  95: GOTO F95; // --> Ziel BYTE auf 1 schreiben
  96: GOTO F96; // --> Ziel WORD auf 1 schreiben
  97: GOTO F97; // --> Ziel BYTE auf 0 schreiben
  98: GOTO F98; // --> Ziel WORD auf 0 schreiben
  99: GOTO F99; // --> Ziel DWORD auf 0 schreiben
  
  //1: Entladen DB227 --> DB137
  101: GOTO F101;  
  102: GOTO F102;
  103: GOTO F103;
  104: GOTO F104;
  105: GOTO F105;
  106: GOTO F106;
  107: GOTO F107;
  108: GOTO F108;
  109: GOTO F109;
  110: GOTO F110;
  111: GOTO F111;
  112: GOTO F112;
  113: GOTO F113;
  114: GOTO F114;
  115: GOTO F115;
  116: GOTO F116;
  117: GOTO F117;
  118: GOTO F118;
  119: GOTO F119;
  120: GOTO F120;
  121: GOTO F121;
  122: GOTO F122;
  123: GOTO F123;
  124: GOTO F124;
  125: GOTO F125;

  188: GOTO F188;//Bei Drehwerkzeugen die Länge1 und Länge2 vertauschen (Ruag)
  189: GOTO F189;//Auto WZ-Größen Erkennung im Standardformat mit Werten aus Wizzard
  190: GOTO F190;//Auto WZ-Größen Erkennung im Standardformat mit Werten aus Wizzard
  191: GOTO F191;//Auto Schneidenanzahl Ermittlung
  192: GOTO F192;//Auto WZ-Größen Erkennung
  193: GOTO F193;//2#10110000(B0)-->Byte
  194: GOTO F194; // --> Ziel BIT  auf 1 schreiben
  195: GOTO F195; // --> Ziel BYTE auf 1 schreiben
  196: GOTO F196; // --> Ziel WORD auf 1 schreiben
  197: GOTO F197; // --> Ziel BYTE auf 0 schreiben
  198: GOTO F198; // --> Ziel WORD auf 0 schreiben
  199: GOTO F199; // --> Ziel DWORD auf 0 schreiben
  
END_CASE ; 
GOTO FEND; 

// Wandung von BCD (2Byte) nach INT
F1: DB_VGL_DMTDC.Fkt5.I_BCD_1 := DB137.DBW[abByte];
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=5);
    DB227.DW[ziel]:= DINT_TO_WORD(REAL_TO_DINT(DB_VGL_DMTDC.Fkt5.O_REAL)); 
    GOTO FEND;

// Int (2Byte) --> Int(2Byte)
F2: Erg_Int := WORD_TO_INT(DB137.DBW[abByte]);
     DB227.DBW[ziel]:= INT_TO_WORD(Erg_Int); 
    GOTO FEND;
      
// (1Byte) --> (1Byte)
F3: Erg_Byte := DB137.DBB[abByte];
    DB227.DBB[ziel]:= Erg_Byte; 
    GOTO FEND;

// Integer (4Byte) --> Real (4Byte)
F4: DB_VGL_DMTDC.Fkt2.I_DINT := DWORD_TO_DINT(DB137.DBD[abByte]); 
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=2);
    DB227.DBD[ziel]:=REAL_TO_DWORD(DB_VGL_DMTDC.Fkt2.O_REAL/Faktor); 
    GOTO FEND;

// String[] --> String[32](Simatic)
F5: DB227.DBB[text_227] := 32;
    k:=0;
    FOR j := 0 TO  (AnzByte-1) BY 1 DO
        IF DB137.dbb[abByte+j] <> 16#20 THEN
             DB227.dbb[text_227+2+k] := db137.dbb[abByte+j];
             k:= k+1;
        END_IF;
        DB227.DBB[(text_227+1)] := WORD_TO_BYTE(INT_TO_WORD(k));
    END_FOR;
    GOTO FEND;
   
// BCD (8Byte) --> String[32](Simatic)
F6: DB229.DBB[text_pos] := 32;
    DB229.DBB[text_pos+1] := WORD_TO_BYTE(INT_TO_WORD(AnzByte*2));
    FOR j := 0 TO  AnzByte-1 BY 1 DO
         BCD_Byte    := db137.dbb[abByte+j];
         BCD_LOW     := BCD_Byte AND 2#00001111;
         BCD_LOW_AS  := BCD_LOW OR 2#00110000;
         BCD_High    := BCD_Byte AND 2#11110000;
         BCD_High    := SHR(IN:=BCD_High,n:=4);
         BCD_High_AS := BCD_High OR 2#00110000;
         DB229.dbb[text_pos+(j*2)+3] := BCD_LOW_AS;
         DB229.dbb[text_pos+(j*2)+2] := BCD_High_AS;       
    END_FOR;
    k:= 0;
    Null_found := FALSE;
    FOR j := 0  TO (AnzByte*2)-1 BY 1 DO
        IF  DB229.dbb[text_pos+j+2] = 16#30 AND NOT Null_found THEN
            DB229.dbb[text_pos+j+2] := 16#20;
        ELSE
            DB227.dbb[text_227+k+(Fuer_Nullen)+2] := DB229.dbb[text_pos+j+2];
            Null_found := TRUE;           
            k:=k+1;
        END_IF;
    END_FOR;
    FOR j := 0  TO (Fuer_Nullen -1) BY 1 DO
      DB227.dbb[text_227+j+2] := 16#30;
    END_FOR;
    DB227.DBB[text_227] := 32;
    DB227.DBB[text_227+1] := WORD_TO_BYTE(INT_TO_WORD(k));
    GOTO FEND;



// Bit aus Byte lesen --> Ziel setzen
F7: Bit_x:= DB137.DX[abByte, Bit_Nr]; 
    DB227.DX[ziel,ziel_Bit_Nr] := Bit_x;
    GOTO FEND;

// Int (2Byte) --> Real /Faktor  
F8: DB_VGL_DMTDC.Fkt2.I_DINT:= DWORD_TO_DINT(WORD_TO_DWORD(DB137.DBW[abByte])); 
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=2);
    DB227.DBD[ziel]:= REAL_TO_DWORD(DB_VGL_DMTDC.Fkt2.O_REAL/Faktor); 
    GOTO FEND;

// DWORD (4Byte) --> DWORD (4Byte)
F9: DB227.DBD[ziel]:= DB137.DBD[abByte]; 
    GOTO FEND;
    
// Char --> Int  ( 1:Standzeit , 2:Stückzahl  --> Überwachungsart) 
F10: ASZeichen := WORD_TO_INT(BYTE_TO_WORD(DB137.DBB[abByte]));
     CASE ASZeichen OF 
        84: Wert := 1; // T
        80: Wert := 2; // P
    ELSE:
        Wert := 0;
    END_CASE;    
     DB227.DBW[ziel] := INT_TO_WORD(Wert);
     GOTO FEND;
     
// Wandung von INT (2Byte) nach HEX (4 Byte)  Bsp. 11INT --> 1 Halpplatz link, 1Halbplatz rechts
F11:k:= WORD_TO_INT(DB137.DBW[abByte]);  
    links := k DIV 10;
    rechts  := k MOD 10;
    DB227.DW[ziel]:= INT_TO_WORD(links);
    DB227.DW[ziel+2]:= INT_TO_WORD(rechts);
    GOTO FEND;

// Werkzeug-Grösse aus Bund-Durchmesser und Werkzeugdurchmesser ermitteln
F12:IF  (((DWORD_TO_INT(DB137.DBW[ziel_Bit_Nr]))>=500) AND ((DWORD_TO_INT(DB137.DBW[ziel_Bit_Nr]))<=540)) THEN
            WZ_DM   := DWORD_TO_DINT(DB137.DBD[AnzByte-8]);
    ELSE
            WZ_DM   := DWORD_TO_DINT(DB137.DBD[AnzByte]);
    END_IF;

    Bund_DM := WORD_TO_INT(DB137.DBW[abByte]);
    IF   Bund_DM > WZ_DM*Faktor THEN  //0.2
         links := 1;
    ELSE    
         links := 2;
    END_IF;    
         DB227.DW[ziel]:= INT_TO_WORD(links);
         DB227.DW[ziel+2]:= INT_TO_WORD(links);
    GOTO FEND;

//4BYTE_BCD-->REAL    D(13)=Minus;E(14)=Komma

F13:FOR j := 0 TO  4 BY 1 DO
         BCD_Byte    := db137.dbb[abByte+j];
         BCD_LOW     := BCD_Byte AND 2#00001111;
         BCD_High    := BCD_Byte AND 2#11110000;
         BCD_High    := SHR(IN:=BCD_High,n:=4);
         
         IF j = 0 THEN
            erg0:=(WORD_TO_INT(BYTE_TO_WORD  (BCD_High)));
            erg1:=(WORD_TO_INT(BYTE_TO_WORD (BCD_LOW)));
         END_IF;
         
         IF j = 1 THEN
            erg2:=(WORD_TO_INT(BYTE_TO_WORD  (BCD_High)));
            erg3:= (WORD_TO_INT(BYTE_TO_WORD (BCD_LOW)));
         END_IF;
        
         IF j = 2 THEN
            erg4:= (WORD_TO_INT(BYTE_TO_WORD  (BCD_High)));
            erg5:= (WORD_TO_INT(BYTE_TO_WORD (BCD_LOW)));
         END_IF;
        
         IF j = 3 THEN
            erg6:= (WORD_TO_INT(BYTE_TO_WORD  (BCD_High)));
            erg7:= (WORD_TO_INT(BYTE_TO_WORD (BCD_LOW)));
         END_IF;
    END_FOR  ;     

  Minus:= False; 
  Ganzzahl:=0;
  Nachkommaz:=0;
  IF erg0 = 13 THEN  
     Minus:= True ;
  END_IF;

  IF erg1 = 14 THEN
  Ganzzahl:= (0);
  Nachkommaz:=(erg2 *0.1 + erg3 *0.01 + erg4 *0.001 + erg5 *0.0001 + erg6 *0.00001 + erg7 *0.000001);
  GOTO a02;
  END_IF;
  
  IF erg2 = 14 THEN
  Ganzzahl:= (erg1 *1);
  Nachkommaz:=(erg3 *0.1 + erg4 *0.01 + erg5 *0.001 + erg6 *0.0001 + erg7 *0.00001);
  GOTO a02;
  END_IF;
  
  IF erg3 = 14 THEN
  Ganzzahl:= (erg1 *10 + erg2 *1);
  Nachkommaz:=(erg4 *0.1 + erg5 *0.01 + erg6 *0.001 + erg7 *0.0001);
  GOTO a02;
  END_IF;

  IF erg4 = 14 THEN
  Ganzzahl:= (erg1 *100 + erg2 *10 + erg3 *1);
  Nachkommaz:=(erg5 *0.1 + erg6 *0.01 + erg7 *0.001);
  GOTO a02;
  END_IF;

  IF erg5 = 14 THEN
  Ganzzahl:= (erg1 *1000 + erg2 *100 + erg3 *10 + erg4 *1);
  Nachkommaz:=(erg6 *0.1 + erg7 *0.01);
  GOTO a02;
  END_IF;
 
  IF erg6 = 14 THEN
  Ganzzahl:= (erg1 *10000 + erg2 *1000 + erg3 *100 + erg4 *10 + erg5 *1);
  Nachkommaz:=(erg7 *0.1);
  GOTO a02;
  END_IF;

  IF erg7 = 14 THEN
  Ganzzahl:= (erg1 *100000 + erg2 *10000 + erg3 *1000 + erg4 *100 + erg5 *10 + erg6 *1);
  GOTO a02;
  END_IF;

  Ganzzahl:= (erg1 *1000000 + erg2 *100000 + erg3 *10000 + erg4 *1000 + erg5 *100 + erg6 *10 + erg7 *1);
  
  a02:IF Minus=TRUE THEN
       DB227.DBD[ziel]:= REAL_TO_DWORD((Ganzzahl + Nachkommaz)*(-1));
    ELSE     
       DB227.DBD[ziel]:= REAL_TO_DWORD(Ganzzahl + Nachkommaz);
    END_IF;
    GOTO FEND;

//-----------------------------------------------------------------------------------------------------------------------

        
//2BYTE_BCD--> 4x Word Nebebplätze jede Stelle 1Nebenplatz
        
F14:BCD_Word    := DB137.DBW[abByte];   
    BCD_1Dek     := BCD_Word AND 2#0000000000001111;
   
    BCD_2Dek     := BCD_Word AND 2#0000000011110000;
    BCD_2Dek    := SHR(IN:=BCD_2Dek,n:=4);

    BCD_3Dek     := BCD_Word AND 2#0000111100000000;
    BCD_3Dek    := SHR(IN:=BCD_3Dek,n:=8);

    BCD_4Dek     := BCD_Word AND 2#1111000000000000;
    BCD_4Dek    := SHR(IN:=BCD_4Dek,n:=12);
  
   
            DB227.DBW[ziel]:=BCD_1Dek;
            DB227.DBW[ziel+2]:=BCD_2Dek;
            DB227.DBW[ziel+4]:=BCD_3Dek;
            DB227.DBW[ziel+6]:=BCD_4Dek;

    GOTO FEND;
  
//2BYTE_BCD-->4BYTE_REAL
F15: BCD_WORD_a:=DB137.DBW[abByte];
    
     BCD_WORD_c:=BCD_WORD_a AND 2#1111000000000000;
    
     BCD_WORD_c:= SHR(IN:=BCD_WORD_c,n:=12);
     BCD_WORD_d:=WORD_TO_INT (BCD_WORD_c);
     
         IF BCD_WORD_d > 9 THEN  //2#0000000000001011
     
         BCD_WORD_b:=BCD_WORD_a AND 2#0000111111111111;
     ELSE 
         BCD_WORD_b:=BCD_WORD_a;
     END_IF;
    
     DB_VGL_DMTDC.Fkt5.I_BCD_1 := BCD_WORD_b;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=5);
     DB227.DBD[ziel]:= REAL_TO_DWORD(DB_VGL_DMTDC.Fkt5.O_REAL); 
     
     //Option wenn BitNR auf eins dann noch Typenwandlung (für Firma Walter Fräser 100 nach 120
     //                                                                     Drehwerkzeug 200 nach 500)
     IF ziel_Bit_Nr = 1 THEN
          CASE REAL_TO_INT(DWORD_TO_REAL(DB227.DBD[ziel])) OF
              100:  DB227.DBD[ziel]:= REAL_TO_DWORD(INT_TO_REAL(120));  // Fräser
                    GOTO FEND;
              200:  DB227.DBD[ziel]:= REAL_TO_DWORD(INT_TO_REAL(500));  // Drehwerkzeug
                    GOTO FEND;
          END_CASE;
     END_IF;
     GOTO FEND;



// (1bcd) --> (1Byte)
F16: BCD_BYTE_1 := BYTE_TO_WORD(DB137.DBB[abByte]);
     BCD_BYTE_a:=(BCD_BYTE_1 AND 2#0000000011110000);
     BCD_BYTE_a:=(SHR(IN:=BCD_BYTE_a,n:=4));
     BCD_BYTE_c:=WORD_TO_INT(BCD_BYTE_a);
     IF BCD_BYTE_c >9 THEN
        BCD_BYTE_b:=BCD_BYTE_1 AND 2#0000000000001111;
     ELSE    
        BCD_BYTE_b:= BCD_BYTE_1;
     END_IF;   
     DB227.DBW[ziel]:= BCD_BYTE_b; 
     DB_VGL_DMTDC.Fkt1.I_BCD := BCD_BYTE_b;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=1);
     DB227.DW[ziel]:= INT_TO_WORD(DB_VGL_DMTDC.Fkt1.O_INT); 
     GOTO FEND;


//3BYTE_BCD-->4BYTE_REAL
F17: BCD_WORD_x:=DB137.DBW[abByte+1];
    
     BCD_WORD_y:=BCD_WORD_x AND 2#1111000000000000;
    
     BCD_WORD_y:= SHR(IN:=BCD_WORD_y,n:=12);
     BCD_WORD_z:=WORD_TO_INT (BCD_WORD_y);
     
         IF BCD_WORD_z > 9 THEN  //2#0000000000001011
     
         BCD_WORD_w:=BCD_WORD_x AND 2#0000111111111111;
     ELSE 
         BCD_WORD_w:=BCD_WORD_x;
     END_IF;
    
     DB_VGL_DMTDC.Fkt5.I_BCD_1 := BCD_WORD_w;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=5);
     DB227.DBD[ziel]:= REAL_TO_DWORD(DB_VGL_DMTDC.Fkt5.O_REAL); 
     GOTO FEND;

//BCD (4Byte) --> Real (4Byte)
//00014747   entspricht Länge von 147.47
//Komma nach der 6.Stelle
//1.Stelle   0= positiver Wert
//10008640   entspricht Wert  -86.40
//Komma nach der 6.Stelle
//1.Stelle   1= minus Wert
F18: F18_BCD1:=DB137.DBD[abByte]AND 2#00010000000000000000000000000000; 
     IF F18_BCD1 = 2#00010000000000000000000000000000 THEN 
        F18_BCD2:= DB137.DBD[abByte] OR  2#11110000000000000000000000000000; 
     ELSE
       F18_BCD2:= DB137.DBD[abByte];
     END_IF;  
       
     DB_VGL_DMTDC.Fkt8.I_BCD :=F18_BCD2;// (DB137.DBD[abByte]) ;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=8);
    // md990:= DB_VGL_DMTDC.Fkt8.O_REAL; //REAL_TO_DWORD((DWORD_TO_REAL(DB_VGL_DMTDC.Fkt8.O_REAL))/Faktor); 
    // md994:= (REAL_TO_DWORD ((DWORD_TO_REAL(md990))/Faktor)) ;
    // md980:= md994/Faktor;
    // md984:= REAL_TO_DWORD (md980);
    DB227.DBD[ziel]:=(REAL_TO_DWORD ((DWORD_TO_REAL(DB_VGL_DMTDC.Fkt8.O_REAL))/Faktor)) ;
  GOTO FEND;

//BCD (3Byte) --> Real (4Byte)
//000229     entspricht 0.229
//Komma nach der 3.Stelle
//100188     entspricht -0.188
//Komma nach der 3.Stelle
F19:BCD_DWORD_11:=DB137.DBD[abByte];
    
   
    
    
    BCD_DWORD_113:=BCD_DWORD_11 AND 2#00001111111111111111111100000000;  //Wert auslesen und nach rechts verschieben da vier anstatt drei Byte gelesen wurden
    BCD_DWORD_113:= SHR(IN:=BCD_DWORD_113,n:=8);
        
    BCD_DWORD_14:=BCD_DWORD_113 or BCD_DWORD_112;  //Vorzeichen und Wert zusammenbauen


     BCD_DWORD_12:=BCD_DWORD_11 AND 2#11110000000000000000000000000000;  //Vorzeichen auslesen 1=negativ; 0=positiv    
      IF BCD_DWORD_12 = 2#00010000000000000000000000000000 THEN 
        BCD_DWORD_14:=BCD_DWORD_113 OR  2#11110000000000000000000000000000; 
     ELSE
       BCD_DWORD_14:=BCD_DWORD_113;
     END_IF;  

     DB_VGL_DMTDC.Fkt8.I_BCD := ((BCD_DWORD_14)) ;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=8);
     DB227.DBD[ziel]:= (REAL_TO_DWORD((DWORD_TO_REAL(DB_VGL_DMTDC.Fkt8.O_REAL))/Faktor)); //((DB_VGL_DMTDC.Fkt8.O_REAL)); //(REAL_TO_DWORD(Faktor))

      GOTO FEND;


//Low Bits aus Byte BCD --> 2Byte INT

F20: BCD_F20_1 := DB137.DBB[abByte];
     BCD_F20_2 := BCD_F20_1 AND 2#00001111; 
     BCD_F20_save := BCD_F20_1 AND 2#11110000;  //High Bits für Rausschreiben wegspeichern
   
  //   BCD_F20_2 := SHR(IN:=BCD_F20_2,n:=4);//Bei Low dann nicht !!
  //  IF Bit_Nr=1 THEN     //Wenn im Bit_Nr eine 1 dann wird das HighByte rausgeholt
  //  BCD_F20_save :=SHR(IN:=BCD_F20_save,n:=4);
  //  DB_VGL_DMTDC.Fkt1.I_BCD := BYTE_TO_WORD(BCD_F20_save);
  //  Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=1);
  //  DB227.DW[ziel]:= INT_TO_WORD(DB_VGL_DMTDC.Fkt1.O_INT); 
  //  ELSE        
    DB_VGL_DMTDC.Fkt1.I_BCD := BYTE_TO_WORD(BCD_F20_2);
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=1);
    DB227.DW[ziel]:= INT_TO_WORD(DB_VGL_DMTDC.Fkt1.O_INT); 
    //mw994:=INT_TO_WORD(DB_VGL_DMTDC.Fkt1.O_INT);
  //  END_IF;
  GOTO FEND;


//Geotyp Erkennung (FA.Reintjes)
F21:     IF ((DB137.DBB[abByte] = 16#11) OR (DB137.DBB[abByte] = 16#12)OR(DB137.DBB[abByte] = 16#10))THEN          //ChipGeoTyp 11 dann Bohrer 16#A
            DB227.DBD[ziel]:= REAL_TO_DWORD (200.0);
            Zaehler:=1;
            GOTO FEND;
         END_IF;
         IF (DB137.DBB[abByte] = 16#20)THEN  //ChipGeotyp 20 dann Fräser  16#14 OR 16#1E
            DB227.DBD[ziel]:= REAL_TO_DWORD (120.0);
            Zaehler:=1;
            GOTO FEND;
         END_IF;   
            Error := TRUE;
            State := 1004;

GOTO FEND;


//Geometrietypkonverierung / Geißlinger

F22:
 IF (index = ziel_Bit_Nr) THEN  //nur beim ersten Werkzeugtyp da sonst wenn nur eine Schneide vorhanden 
         IF DB137.DBB[abByte] = 16#10 THEN          //ChipGeoTyp 10 dann Bohrer 16#A
            DB227.DBD[ziel]:= REAL_TO_DWORD (200.0);
            Zaehler:=1;
            GOTO FEND;
         END_IF;
         IF (DB137.DBB[abByte] = 16#20) OR (DB137.DBB[abByte] = 16#30) THEN  //ChipGeotyp 20/30 dann Fräser  16#14 OR 16#1E
            DB227.DBD[ziel]:= REAL_TO_DWORD (120.0);
            Zaehler:=1;
            GOTO FEND;
         END_IF;   
            Error := TRUE;
            State := 1004;
  END_IF;
 GOTO FEND;


//ASCII[] TO REAL[4Byte] 

F23:s:=0;
    t:=0;
    u:=0;
    Gleitp:=false;
    Vorz:=false;
    DB_VGL_DMTDC.SchmiermDW:=0;
    v:= false;

    FOR j := 0 TO  12 BY 1 DO  //abnullen des Schmierbereichs
           DB229.dbb[154+j] := 0;       
         END_FOR;  
 
    FOR s:=0 TO (AnzByte-1) BY 1 DO
        IF (db137.dbb[abByte+s] <> 32) AND (db137.dbb[abByte+s] <> 48) AND (db137.dbb[abByte+s] <> 0) OR (v = true) THEN  //Wenn CHAR ist ungleich leer(32) od 0(48) 
            IF (db137.dbb[abByte+s] = 45)  OR (db137.dbb[abByte+s] = 43) THEN //Wenn CHAR ist +(43)/-(45)
               IF (db137.dbb[abByte+s] = 45) THEN
                   Vorz := true;
               END_IF;    
               GOTO F23end;
            END_IF;
            IF (db137.dbb[abByte+s] = 46) THEN  // Dezimalpunkt
               Gleitp:=true;
               GOTO F23end;
            END_IF;    
            IF ((BYTE_TO_INT(db137.dbb[abByte+s]) >= 48) AND (BYTE_TO_INT(db137.dbb[abByte+s]) <= 57)) THEN// THEN//Wenn keine Zahl dann Fehler
                DB229.dbb[154+t]:= (INT_TO_BYTE(BYTE_TO_INT(DB137.DBB[abByte+s])-48));//AUS ASCII INT
                t:= t+1;
                v:= true;
                db229.dbw170:=INT_TO_WORD(t);
            ELSE
                Error := TRUE;
                State := 1007;
            END_IF;
            F23end: ;
        END_IF;
    END_FOR;       
          
    FOR u:=0 TO (t-1) BY 1 DO
       Merker:= INT_TO_REAL(BYTE_TO_INT(DB229.dbb[154+u]));//(EXPD(t-u));//+ DB_VGL_DMTDC.SchmiermDW); // (t-u)(INT_TO_DWORD
       Merker:= EXPD(t-u-1)*Merker;
       DB_VGL_DMTDC.SchmiermDW:= DINT_TO_REAL((REAL_TO_DINT (Merker)) + (REAL_TO_DINT (DB_VGL_DMTDC.SchmiermDW)) );
    END_FOR;

    IF  (Vorz = true)   THEN
        DB_VGL_DMTDC.SchmiermDW:= (((DB_VGL_DMTDC.SchmiermDW)) * (-1.0));   
    END_IF;
    IF (Gleitp = true) THEN
        DB_VGL_DMTDC.SchmiermDW:=(((DB_VGL_DMTDC.SchmiermDW))/1000.0);
    END_IF;    
    CASE ziel_Bit_Nr OF //UNTERFUNKTION
        1: CASE (DINT_TO_INT(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW)))OF
            1: DB227.DBW[ziel]:=1;
               DB227.DBW[ziel+2]:=1;
               DB227.DBW[ziel+4]:=1;
               DB227.DBW[ziel+6]:=1;
               GOTO FEND;
            3: DB227.DBW[ziel]:=3;
               DB227.DBW[ziel+2]:=3;
               DB227.DBW[ziel+4]:=1;
               DB227.DBW[ziel+6]:=1;
               GOTO FEND;
           ELSE
                Error := TRUE;
                State := 1006;
                GOTO FEND;
           END_CASE;    
           GOTO FEND;
        2: CASE (DINT_TO_INT(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW)))OF
            1:DB227.DBW[ziel]:=2; //freigegeben
              GOTO FEND;
            2:DB227.DBW[ziel]:=6; //gesperrt
              GOTO FEND;
            3:DB227.DBW[ziel]:=6;//Vorwahrngrenze
              Error := TRUE;
              State := 1007;
              GOTO FEND;
           END_CASE;
            GOTO FEND;
        3: CASE (DINT_TO_INT(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW)))OF
            10:DB227.DBD[ziel]:=REAL_TO_DWORD (200.0); //Bohrer       
               GOTO FEND;
            20:DB227.DBD[ziel]:=REAL_TO_DWORD (120.0); //Fräser
               GOTO FEND;
            30:DB227.DBD[ziel]:=REAL_TO_DWORD (120.0);//Fräser
               GOTO FEND;
           END_CASE;

         GOTO FEND;
     END_CASE;     
         
    IF (anzByte<=5) THEN
    DB227.DBw[ziel]:=(DINT_TO_WORD(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW)));
    ELSE    
    DB227.DBD[ziel]:=REAL_TO_DWORD(DB_VGL_DMTDC.SchmiermDW);
    END_IF;
                   
 GOTO FEND;
//4BYTE BCD --> REAL 4 Vorkaommastellen & 4 Nachkommastellen
F24: BCD_DWORD_113:= DB137.DBD[abByte];
     BCD_DWORD_113:=SHR(IN:=BCD_DWORD_113,n:=4);

     DB_VGL_DMTDC.Fkt8.I_BCD := BCD_DWORD_113;// (DB137.DBD[abByte]) ;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=8);
     DB227.DBD[ziel]:=REAL_TO_DWORD((DWORD_TO_REAL(DB_VGL_DMTDC.Fkt8.O_REAL))/(Faktor/10));
 GOTO FEND;

F25: GOTO FEND;

// Bei Drehwerkzeugen die Länge1 und Länge2 vertauschen (Ruag)
F88:IF  (WORD_TO_INT(db137.dbw[ziel_Bit_Nr])>= 500)  AND (WORD_TO_INT(db137.dbw[ziel_Bit_Nr])<= 540) THEN
          FOR u:=0 TO (DWORD_TO_INT(DB227.DBW[22])) BY 1 DO
            xx01 := DB227.DBD[156+(u*204)] ;
            xx02 := DB227.DBD[160+(u*204)] ;
            DB227.DBD[160+(u*204)] := xx01 ;
            DB227.DBD[156+(u*204)] := xx02 ;
          END_FOR;  
    END_IF;
 GOTO FEND;

//-----------------------------------------------------------------------------------------------------------------------
//Anwahl Hex30 Bit7 
//Auto Werkzeuggrößenerkennung  mit Nominalwerten welche auf dem Chip vorhanden sind
//DB227.CC_WZ_Parameter[3] := 1=normal;0=lang (Standardformat)
//Bezugswerte werden aus Wizzard(DB229) gezogen. Pos_length/Pos_radius werden aus DB228 gezogen.(Format)
////Typ 1: OEM Datum Werkzeug kurz (Länge < 250 mm)  und  Halbplätze = 1 gesperrt 

F89:IF ((DB_PLC_MD_DB20.UDhex._30_Bit7_TDS_Auto_WZGroe = 0)AND (DB_KONFIG_DMTDC.format_number = 11)) THEN//Anwahl
       GOTO FEND;
    END_IF;
    //Wenn keine Nominalwerte auf dem Chip vorhanden dann Abbrechen und Fehler ausgeben!
    IF (DWORD_TO_REAL (DB137.DBD[Pos_length]))<= 0 OR (DWORD_TO_REAL(DB137.DBD[Pos_radius]))<= 0 OR ((DWORD_TO_REAL(DB137.DBD[Pos_radius+4])))<= 0 THEN
       Error := TRUE;
       State := 1009;
       GOTO FEND;
    END_IF;
    //Überprüfung ob Position der Nominalwerte auf dem Chip vorhanden? 
    IF DB_KONFIG_DMTDC.Tool_size.pos_length = 0 OR DB_KONFIG_DMTDC.Tool_size.pos_radius = 0 THEN  
       Error := TRUE;
       State := 1008;
       GOTO FEND;
    END_IF;
   //Auskodierung welcher Maschinentyp bzw. werlcher Magazinty?
    Regal160ger := false;
    x := 260; //Bis Bereich Typ6 im DB229 
    y := 288; //Bis Bereich Typ6 im DB229 
    IF (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3081) OR (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3080) AND (INT_TO_DINT (DB_PLC_MD_DB20.UDint._008_ANWAHL_WZW_TYP) = 6) THEN //Wenn 160ger
        Regal160ger := true;
        x := 252;//Bis Bereich Typ3 im DB229
        y := 284;//Bis Bereich Typ3 im DB229
    END_IF;    
   
   IF (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3066) OR (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3067) AND (INT_TO_DINT (DB_PLC_MD_DB20.UDint._008_ANWAHL_WZW_TYP) = 10) THEN //Wenn 200 mit Regal
        Regal160ger := true;
        x := 252;//Bis Bereich Typ3 im DB229
        y := 284;//Bis Bereich Typ3 im DB229
   END_IF;    
   
   IF (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3090) AND (INT_TO_DINT (DB_PLC_MD_DB20.UDint._008_ANWAHL_WZW_TYP) = 10) THEN //Wenn 340 mit Regal
        Regal160ger := true;
        x := 252;//Bis Bereich Typ3 im DB229
        y := 284;//Bis Bereich Typ3 im DB229
   END_IF;    
  
   // Überprüfung ob Vergleichswerte im Wizzard/DB229 vorhanden
    FOR u:=238 TO (x) BY 2 DO      //Überprüfung ob Werte im DB229 vorhanden
        IF DB229.DBW[u] = 0 THEN
           Error := TRUE;
           State := 1008;
        GOTO FEND;   
        END_IF;
    END_FOR;
    FOR u:=278 TO (y) BY 2 DO      //Überprüfung ob Werte Raidus Y vorhanden
        IF DB229.DBW[u] = 0 THEN
           Error := TRUE;
           State := 1008;
        GOTO FEND;   
        END_IF;
    END_FOR;

 //---------------------------------------------------------------------------------------------------------------------------------------------------------------
    ////160gerRegal Auswertung
    IF (Regal160ger = true) THEN
    DB_WZV_DV.Groesse_Links := 1;
    DB_WZV_DV.Groesse_Rechts := 1;
    DB_WZV_DV.CC_WZ_Parameter[3] := 0;
    ////       MagTyp 1:  (Länge < 650 mm & Radius X < WZTyp1.Radius & Radius Y < WZABM.TYP1RadiusY)    Halbplätze = 1 gesperrt  
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Radius 
        AND DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP1RadiusY THEN 
           DB_WZV_DV.Groesse_Oben := 1;
           DB_WZV_DV.Groesse_Unten := 1;
           DB_WZV_DV.Mag_Platz_Typ := 1;
           GOTO FEND;
        END_IF;
    // Rausgenommen da Magtyp2 auh auf den Magtyp3 Platz beladen werden soll da dieser aber schmäler ist muss jeder Typ 2 mit 2 Halbplätzen angelegt werden!!sth 06.11.07
    ////       MagTyp 2: (Länge < 650 mm & Radius X < WZTyp2.Radius & Radius Y < WZTyp2.Radius)  Halbplätze = 1 gesperrt 
    //    IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.TYP2RadiusY 
    //    AND DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP2RadiusY THEN 
    //       DB_WZV_DV.Groesse_Oben := 1;
    //       DB_WZV_DV.Groesse_Unten := 1;
    //       DB_WZV_DV.Mag_Platz_Typ := 2;
    //       GOTO FEND;
    //    END_IF;
    ////       MagTyp 2: (Länge < 650 mm & Radius X < WZTyp2.Radius & Radius Y < WZABM.TYP2RadiusY)  Halbplätze = 2 gesperrt 
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Radius 
        AND DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP2RadiusY THEN 
           DB_WZV_DV.Groesse_Oben := 2;
           DB_WZV_DV.Groesse_Unten := 2;
           DB_WZV_DV.Mag_Platz_Typ := 2;
           GOTO FEND;
        END_IF;
    ////       MagTyp3: (Länge < 650 mm & Radius X < WZTyp3.Radius & Radius Y < WZABM.TYP3RadiusY) Halbplätze = 1 gesperrt
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Radius 
        AND DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP3RadiusY THEN 
           DB_WZV_DV.Groesse_Oben := 1;
           DB_WZV_DV.Groesse_Unten := 1;
           DB_WZV_DV.Mag_Platz_Typ := 3;
           GOTO FEND;
        END_IF;
    ////       MagTyp3:  (Länge < 650 mm & Radius X < WZTyp4.Radius & Radius Y < WZABM.TYP4RadiusY) Halbplätze = 2 gesperrt
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Radius 
        AND DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP4RadiusY THEN 
           DB_WZV_DV.Groesse_Oben := 2;
           DB_WZV_DV.Groesse_Unten := 2;
           DB_WZV_DV.Mag_Platz_Typ := 3;
           GOTO FEND;
        END_IF;
        //Wenn ungültige Werte vorhanden dann Fehler ausgebeb!
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) > DB_VGL_DMTDC.WZABM.WZTyp4.Laenge THEN
        Error := TRUE;
        State := 1003;
        END_IF;
        IF DWORD_TO_REAL (DB137.DBD[Pos_radius]) > DB_VGL_DMTDC.WZABM.WZTyp4.Radius THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        IF DWORD_TO_REAL (DB137.DBD[Pos_radius+4]) > DB_VGL_DMTDC.WZABM.TYP4RadiusY THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        DB_WZV_DV.Groesse_Oben := 0;
        DB_WZV_DV.Groesse_Unten := 0;
        DB_WZV_DV.Mag_Platz_Typ := 0;
        GOTO FEND;

    ELSE
 //---------------------------------------------------------------------------------------------------------------------------------------------------------------
      ////P2 Kette Auswertung
        DB_WZV_DV.Groesse_Oben := 1;
        DB_WZV_DV.Groesse_Unten := 1;
        DB_WZV_DV.Mag_Platz_Typ := 1;
    ////       Typ 1: OEM Datum Werkzeug kurz (Länge < 250 mm)  und  Halbplätze = 1 gesperrt 
        IF ((DWORD_TO_REAL(DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Laenge) AND (DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Radius)
           AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP1RadiusY))  THEN 
           DB_WZV_DV.Groesse_Links := 1;
           DB_WZV_DV.Groesse_Rechts := 1;
           DB_WZV_DV.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////       Typ 2: OEM Datum Werkzeug kurz (Länge < 250 mm)  und (2/3 Halbplatz links und/oder rechts gesperrt)
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Radius 
        AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP2RadiusY) THEN 
           DB227.Groesse_Links := 3;
           DB227.Groesse_Rechts := 3;
           DB227.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////       Typ3: OEM Datum Werkzeug kurz (Länge < 250 mm)  und (4/5 Halbplätze links und/oder rechts)
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Radius 
        AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP3RadiusY) THEN 
           DB227.Groesse_Links := 5;
           DB227.Groesse_Rechts := 5;
           DB227.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////        Typ6: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und Halbplätze 1
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp6.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp6.Radius 
        AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP6RadiusY) THEN 
           DB227.Groesse_Links := 1;
           DB227.Groesse_Rechts := 1;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
    ////           Typ5: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und  (2/3 Halbplatz links und/oder  2/3 Halbplätze rechts gesperrt)
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp5.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp5.Radius 
        AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP5RadiusY) THEN 
           DB227.Groesse_Links := 3;
           DB227.Groesse_Rechts := 3;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
    ////            Typ4: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und  (4/5 Halbplätze links und/oder rechts)
        IF DWORD_TO_REAL (DB137.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Laenge AND DWORD_TO_REAL (DB137.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Radius 
        AND (DWORD_TO_REAL (DB137.DBD[(Pos_radius+4)]) <= DB_VGL_DMTDC.WZABM.TYP4RadiusY) THEN 
           DB227.Groesse_Links := 5;
           DB227.Groesse_Rechts := 5;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
   //Wenn ungültige Werte vorhanden dann Fehler ausgeben!!
    IF DWORD_TO_REAL (DB137.DBD[Pos_length]) > DB_VGL_DMTDC.WZABM.WZTyp6.Laenge THEN
        Error := TRUE;
        State := 1003;
        END_IF;
        IF DWORD_TO_REAL (DB137.DBD[Pos_radius]) > DB_VGL_DMTDC.WZABM.WZTyp4.Radius THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        IF DWORD_TO_REAL (DB137.DBD[Pos_radius+4]) > DB_VGL_DMTDC.WZABM.TYP3RadiusY THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        DB227.Groesse_Links := 0;
        DB227.Groesse_Rechts := 0;
        DB227.CC_WZ_Parameter[3] := 0;
        GOTO FEND;
   END_IF;
   GOTO FEND;

//-----------------------------------------------------------------------------------------------------------------------
//Anwahl Hex30 Bit7 
//Auto Werkzeuggrößenerkennung   DB227.CC_WZ_Parameter[3] := 1=normal;0=lang (Standardformat)
//Bezugswerte werden aus Wizzard(DB229) gezogen. Pos_length/Pos_radius werden aus DB228 gezogen.(Format)
////      Typ 1: OEM Datum Werkzeug kurz (Länge < 250 mm)  und  Halbplätze = 1 gesperrt 
F90:IF (DB_PLC_MD_DB20.UDhex._30_Bit7_TDS_Auto_WZGroe = 0) THEN//Anwahl
       GOTO FEND;
    END_IF;
        IF DB_KONFIG_DMTDC.Tool_size.pos_length = 0 OR DB_KONFIG_DMTDC.Tool_size.pos_radius = 0 THEN  //Überprüfung ob Werte vorhanden?
       Error := TRUE;
       State := 1008;
       GOTO FEND;
    END_IF;
    Regal160ger := false;
    x := 260; //Bis Bereich Typ6 im DB229 
    IF (INT_TO_DINT (DB_PLC_MD_DB20.UDint._000_STANDORT_MASCHTYP) = 3081) THEN //Wenn 160ger
        Regal160ger := true;
        x := 248;//Bis Bereich Typ3 im DB229
    END_IF;    
   
    FOR u:=238 TO (x) BY 2 DO      //Überprüfung ob Werte vorhanden
        IF DB229.DBW[u] = 0 THEN
           Error := TRUE;
           State := 1008;
        GOTO FEND;   
        END_IF;
    END_FOR;
    
    IF (Regal160ger = true) THEN
    ////160gerRegal Auswertung
    DB_WZV_DV.Groesse_Links := 1;
    DB_WZV_DV.Groesse_Rechts := 1;
    DB_WZV_DV.CC_WZ_Parameter[3] := 0;
    ////       MagTyp 1:  (Länge < 650 mm Radius < WZTyp1.Radius )  und  Halbplätze = 1 gesperrt  
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Radius  THEN 
           DB_WZV_DV.Groesse_Oben := 1;
           DB_WZV_DV.Groesse_Unten := 1;
           DB_WZV_DV.Mag_Platz_Typ := 1;
           GOTO FEND;
        END_IF;
    ////       MagTyp 2: (Länge < 650 mm Radius < WZTyp2.Radius )  und  Halbplätze = 1 gesperrt 
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Radius  THEN 
           DB_WZV_DV.Groesse_Oben := 1;
           DB_WZV_DV.Groesse_Unten := 1;
           DB_WZV_DV.Mag_Platz_Typ := 2;
           GOTO FEND;
        END_IF;
    ////       MagTyp3: (Länge < 650 mm Radius < WZTyp3.Radius ) Halbplätze = 2 gesperrt
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Radius  THEN 
           DB_WZV_DV.Groesse_Oben := 2;
           DB_WZV_DV.Groesse_Unten := 2;
           DB_WZV_DV.Mag_Platz_Typ := 3;
           GOTO FEND;
        END_IF;
    ////       MagTyp3:  (Länge < 650 mm Radius > WZTyp3.Radius < WZTyp4.Radius ) Halbplätze = 3 gesperrt
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Radius THEN 
           DB_WZV_DV.Groesse_Oben := 3;
           DB_WZV_DV.Groesse_Unten := 3;
           DB_WZV_DV.Mag_Platz_Typ := 3;
           GOTO FEND;
        END_IF;
        //Wenn ungültige Werte vorhanden
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) > DB_VGL_DMTDC.WZABM.WZTyp4.Laenge THEN
        Error := TRUE;
        State := 1003;
        END_IF;
        IF DWORD_TO_REAL (DB227.DBD[Pos_radius]) > DB_VGL_DMTDC.WZABM.WZTyp4.Radius THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        DB_WZV_DV.Groesse_Oben := 0;
        DB_WZV_DV.Groesse_Unten := 0;
        DB_WZV_DV.Mag_Platz_Typ := 0;
               GOTO FEND;

    ELSE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      ////P2 Kette Auswertung
        DB_WZV_DV.Groesse_Oben := 1;
        DB_WZV_DV.Groesse_Unten := 1;
        DB_WZV_DV.Mag_Platz_Typ := 1;
    ////       Typ 1: OEM Datum Werkzeug kurz (Länge < 250 mm)  und  Halbplätze = 1 gesperrt 
        IF ((DWORD_TO_REAL(DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Laenge) AND (DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp1.Radius))  THEN 
           DB_WZV_DV.Groesse_Links := 1;
           DB_WZV_DV.Groesse_Rechts := 1;
           DB_WZV_DV.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////       Typ 2: OEM Datum Werkzeug kurz (Länge < 250 mm)  und (2/3 Halbplatz links und/oder rechts gesperrt)
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp2.Radius  THEN 
           DB227.Groesse_Links := 3;
           DB227.Groesse_Rechts := 3;
           DB227.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////       Typ3: OEM Datum Werkzeug kurz (Länge < 250 mm)  und (4/5 Halbplätze links und/oder rechts)
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp3.Radius  THEN 
           DB227.Groesse_Links := 5;
           DB227.Groesse_Rechts := 5;
           DB227.CC_WZ_Parameter[3] := 1;
           GOTO FEND;
        END_IF;
    ////        Typ6: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und Halbplätze 1
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp6.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp6.Radius  THEN 
           DB227.Groesse_Links := 1;
           DB227.Groesse_Rechts := 1;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
    ////           Typ5: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und  (2/3 Halbplatz links und/oder  2/3 Halbplätze rechts gesperrt)
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp5.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp5.Radius  THEN 
           DB227.Groesse_Links := 3;
           DB227.Groesse_Rechts := 3;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
    ////            Typ4: OEM Datum Werkzeug lang (250 mm Länge <= 500mm)  und  (4/5 Halbplätze links und/oder rechts)
        IF DWORD_TO_REAL (DB227.DBD[Pos_length]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Laenge AND DWORD_TO_REAL (DB227.DBD[Pos_radius]) <= DB_VGL_DMTDC.WZABM.WZTyp4.Radius  THEN 
           DB227.Groesse_Links := 5;
           DB227.Groesse_Rechts := 5;
           DB227.CC_WZ_Parameter[3] := 0;
           GOTO FEND;
        END_IF;
   //Wenn ungültige Werte vorhanden
    IF DWORD_TO_REAL (DB227.DBD[Pos_length]) > DB_VGL_DMTDC.WZABM.WZTyp6.Laenge THEN
        Error := TRUE;
        State := 1003;
        END_IF;
        IF DWORD_TO_REAL (DB227.DBD[Pos_radius]) > DB_VGL_DMTDC.WZABM.WZTyp4.Radius THEN
        Error := TRUE;
        State := 1002;
        END_IF;
        DB227.Groesse_Links := 0;
        DB227.Groesse_Rechts := 0;
        DB227.CC_WZ_Parameter[3] := 0;
        GOTO FEND;
   END_IF;
   GOTO FEND;


//Auto Anzahl Schneiden Ermittlung (Techspace)
F91:mx:=Bit_Nr;
    offsetLR:=ziel_Bit_Nr;
    offsetSchn:=AnzByte;
    q:=0;
    FOR q:=0 TO mx BY 1 DO 
        IF (db227.dbd[abByte+(q*offsetSchn)]= 0) AND (db227.dbd[abByte+(q*offsetSchn)+offsetLR]= 0) THEN
            DB227.DBW[ziel]:= INT_TO_WORD(q);
            GOTO FEND;
        END_IF;            
    END_FOR; 
GOTO FEND;

//Auto Werkzeuggrößenerkennung   DB227.CC_WZ_Parameter[3] := 1=normal;0=lang (Geislinger)
//Bezugswerte werden aus jeweiligem Format gezogen.
F92:IF ((DB_KONFIG_DMTDC.Tool_size.pos_length = 0) OR (DB_KONFIG_DMTDC.Tool_size.pos_radius = 0)) THEN  //Überprüfung ob Werte vorhanden?
       Error := TRUE;
       State := 1008;
       GOTO FEND;
    END_IF;

  //  IF ((DB227.DBD[Pos_length]= 0) OR (DB227.DBD[Pos_radius]= 0)) THEN
  //     Error := TRUE;
  //     State := 1008;
  //     GOTO FEND;
  //  END_IF;
      
    IF DWORD_TO_REAL(DB227.DBD[Pos_length]) <= DB228.Tool_size.length_01 THEN
        IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_01  THEN
            DB227.Groesse_Links := 1;
            DB227.Groesse_Rechts := 1;
            DB227.CC_WZ_Parameter[3] := 1;
            GOTO FEND;
        END_IF;
        IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_02  THEN
            DB227.Groesse_Links := 3;
            DB227.Groesse_Rechts := 3;
            DB227.CC_WZ_Parameter[3] := 1;
            GOTO FEND;
         END_IF;
         IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_03  THEN
            DB227.Groesse_Links := 5;
            DB227.Groesse_Rechts := 5;
            DB227.CC_WZ_Parameter[3] := 1;
            GOTO FEND;
         END_IF;
         IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) > DB228.Tool_size.radius_03  THEN
            Error := TRUE;
            State := 1002;
            GOTO FEND;
         END_IF;
     END_IF;
     
     IF DWORD_TO_REAL(DB227.DBD[Pos_length]) <= DB228.Tool_size.length_02 THEN
        IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_01  THEN
            DB227.Groesse_Links := 1;
            DB227.Groesse_Rechts := 1;
            DB227.CC_WZ_Parameter[3] := 0;
            GOTO FEND;
        END_IF;
        IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_02  THEN
            DB227.Groesse_Links := 3;
            DB227.Groesse_Rechts := 3;
            DB227.CC_WZ_Parameter[3] := 0;
            GOTO FEND;
         END_IF;
         IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) <= DB228.Tool_size.radius_03  THEN
            DB227.Groesse_Links := 5;
            DB227.Groesse_Rechts := 5;
            DB227.CC_WZ_Parameter[3] := 0;
            GOTO FEND;
         END_IF;
         IF  DWORD_TO_REAL(DB227.DBD[Pos_radius]) > DB228.Tool_size.radius_03  THEN
            Error := TRUE;
            State := 1002;
            GOTO FEND;
         END_IF;
     ELSE
         Error := TRUE;
         State := 1003;
     END_IF;
  GOTO FEND;
//2#10110000(B0)-->Byte
F93:GOTO FEND;
// 1 --> Bit
F94:DB227.DBX[ziel,ziel_Bit_Nr]:= 1; 
    GOTO FEND;
// 1 --> Word
F95:DB227.DBW[ziel]:= 1; 
    GOTO FEND;
// 1 --> Byte
F96:DB227.DBB[ziel]:= 1; 
    GOTO FEND;
// 0  --> Byte  
F97:DB227.DBB[ziel]:= 0; 
    GOTO FEND;
// 0  --> WORD  
F98:DB227.DBW[ziel]:= 0; 
    GOTO FEND;
// 0  --> WORD  
F99:DB227.DBD[ziel]:= 0; 
    GOTO FEND;
 

// Wandung von INT --> BCD (2Byte)
F101: DB_VGL_DMTDC.Fkt3.I_INT := WORD_TO_INT(DB227.DW[ziel]);
      Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=3);
      DB137.DBW[abByte]:= DB_VGL_DMTDC.Fkt3.O_BCD; 
      GOTO FEND;

// Int (2Byte) --> Int(2Byte)
F102: DB137.DBW[abByte] := DB227.DBW[ziel];
      GOTO FEND;
      
// (1Byte) --> (1Byte)
F103: DB137.DBB[abByte] := DB227.DBB[ziel]; 
      GOTO FEND;

// Real (4Byte) --> Integer (4Byte) 
F104: DB_VGL_DMTDC.Fkt4.I_REAL:= (DWORD_TO_REAL(DB227.DBD[ziel])*Faktor); 
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=4);
    DB137.DBD[abByte]:= DINT_TO_DWORD(DB_VGL_DMTDC.Fkt4.O_DINT); 
    GOTO FEND;

F105: k:=WORD_TO_INT(BYTE_TO_WORD(DB227.DBB[text_227+1]));
      IF (AnzByte-k) < 0 THEN
           Error := TRUE;
           State := 1001;
           k:= (AnzByte);
      END_IF;
         
 //     FOR j := 0 TO  ((AnzByte-k)-1) BY 1 DO 
 //          db137.dbb[abByte+j]:= 16#20;
 //     END_FOR;
      
 //     FOR j := ((AnzByte-k)) TO ((AnzByte)-1) BY 1 DO
 
 //     FOR j := 0 TO k-1 BY 1 DO 
 //          db137.dbb[abByte+(AnzByte-k)+j]:= DB227.DBB[text_227+j+2] ;
 //     END_FOR;
 
 
      FOR j := 0 TO  ((AnzByte-k)-1) BY 1 DO 
           db137.dbb[abByte+k+j]:= 16#20;
      END_FOR;
 
      FOR j := 0 TO k-1 BY 1 DO 
           db137.dbb[abByte+j]:= DB227.DBB[text_227+j+2] ;
      END_FOR;
  
      GOTO FEND;
    
// String[32](Simatic) --> BCD (8Byte) 
F106: DB_VGL_DMTDC.text := DB227.Wz_Bezeichner;
       akt_laenge := WORD_TO_INT(BYTE_TO_WORD(DB227.dbb33));
       DB229.DBB[text_pos] := 32;  // Max Laenge
       DB229.DBB[text_pos+1] := WORD_TO_BYTE(INT_TO_WORD(akt_laenge)); // akt. Laenge
         k:=(AnzByte*2)-(akt_laenge);   
       IF k < 0 THEN
           Error := TRUE;
           State := 1001;
           k := 0;
       END_IF;
         FOR j := 0 TO  k-1 BY 1 DO
           DB229.dbb[text_pos+2+j] := 16#20;       
         END_FOR;  
         FOR j := 0 TO akt_laenge-1 BY 1 DO
           DB229.dbb[k+2+j] :=DB227.dbb[text_227+2+j];       
         END_FOR;
         FOR j := 0 TO  AnzByte-1 BY 1 DO
           BCD_High_AS:= DB229.dbb[text_pos+(j*2)+2];       
           BCD_LOW_AS := DB229.dbb[text_pos+(j*2)+3];
           BCD_High   := BCD_High_AS AND 2#00001111;
           BCD_High   := SHL(IN:=BCD_High,n:=4);
           BCD_LOW    := BCD_LOW_AS AND 2#00001111;
           BCD_Byte   :=BCD_LOW OR BCD_High;
           DB137.dbb[abByte+j]:= BCD_Byte;
         END_FOR;                         
       GOTO FEND;

// Bit aus Byte lesen --> Ziel setzen
F107: DB137.DX[abByte,Bit_Nr]:= DB227.DX[ziel,ziel_Bit_Nr];
      GOTO FEND;

// Real * Faktor --> Int (2Byte)  
F108: DB_VGL_DMTDC.Fkt4.I_REAL := DWORD_TO_REAL(DB227.DBD[ziel])*Faktor;
       Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=4);
       DB137.DBW[abByte] := DWORD_TO_WORD(DINT_TO_DWORD(DB_VGL_DMTDC.Fkt4.O_DINT));  
      GOTO FEND;

// DWORD (4Byte) --> DWORD (4Byte)
F109: DB137.DBD[abByte]:= DB227.DBD[ziel]; 
      GOTO FEND;
    
// Int --> Char  ( 1:Standzeit , 2:Stückzahl  --> Überwachungsart) 
F110: Wert := WORD_TO_INT(DB227.DBW[ziel]);
      CASE Wert OF 
        1: Zeichen := 'T'; 
        2: Zeichen := 'P';
     ELSE:
         Zeichen := '_';
     END_CASE;    
     DB137.DBB[abByte] := (CHAR_TO_BYTE(Zeichen));
     GOTO FEND;

// Wandung von INT (2Byte) nach HEX (4 Byte)  Bsp. 11INT --> 1 Halpplatz link, 1Halbplatz rechts
F111:links  := WORD_TO_INT(DB227.DW[ziel]);
     rechts := WORD_TO_INT(DB227.DW[ziel+2]);
     k:= links*10 + rechts;  
     DB137.DBW[abByte] := INT_TO_WORD(k);
     GOTO FEND;
        
// Werkzeug-Grösse aus Bund-Durchmesser und Werkzeugdurchmesser ermitteln
F112:GOTO FEND;


F113:IF (DWORD_TO_REAL(DB227.DBD[ziel])) < 0 THEN 
        Negativ:= True;
        Einganswert:= (DWORD_TO_REAL(DB227.DBD[ziel])*(-1));
     ELSE
        Negativ:= False;
        Einganswert:= (DWORD_TO_REAL(DB227.DBD[ziel]));;
     END_IF;

    BCD_CODE:= Einganswert*1000;
     
        "DB_VGL_DMTDC".Fkt6.I_REAL:=BCD_CODE; 
        erg_bool:= FC_DMTDC_FUNKT(I_Fkt:=6);
        "DB_VGL_DMTDC".BCD_4BYTE:=  "DB_VGL_DMTDC".Fkt6.O_BCD; 

     xx01:= "DB_VGL_DMTDC".BCD_4BYTE AND 2#00000000000000000000111111111111;
     xx02:= "DB_VGL_DMTDC".BCD_4BYTE AND 2#00000000111111111111000000000000;
     xx02:=(SHL(IN:=xx02,n:=4));
     xx03:= xx01 OR xx02;
     xx04:= xx03 OR 2#00000000000000001110000000000000;

     IF Negativ = True THEN 
       DB137.DBD[abByte]:= xx04 OR 2#11010000000000000000000000000000;
     ELSE
       DB137.DBD[abByte]:= xx04 OR 2#10110000000000000000000000000000 ;  
     END_IF; 
     GOTO FEND;


// 4x Word Nebebplätze jede Stelle 1Nebenplatz --> 2BYTE_BCD
F114:bcd_word1:= DB227.DBW[ziel+6];
     bcd_word1:= SHL(IN:=bcd_word1,n:=12);
     bcd_word2:=DB227.DBW[ziel+4] ;
     bcd_word2:= SHL(IN:=bcd_word2,n:=8);
     bcd_word3:=DB227.DBW[ziel+2] ;
     bcd_word3:= SHL(IN:=bcd_word3,n:=4);
     bcd_word4:=DB227.DBW[ziel] ;
     DB137.DBW[abByte]:=bcd_word1 OR bcd_word2 OR bcd_word3 OR bcd_word4;
     GOTO FEND;



//2BYTE_BCD-->4BYTE_REAL
  //Option wenn BitNR auf eins dann noch Typenwandlung (für Firma Walter Fräser 100 nach 120
     //                                                                     Drehwerkzeug 200 nach 500)
 F115:IF ziel_Bit_Nr = 1 THEN
          CASE REAL_TO_INT(DWORD_TO_REAL(DB227.DBD[ziel])) OF
              120:  DB227.DBD[ziel]:= REAL_TO_DWORD(INT_TO_REAL(100));  // Fräser
                    
              500:  DB227.DBD[ziel]:= REAL_TO_DWORD(INT_TO_REAL(200));  // Drehwerkzeug
                    
          END_CASE;
     END_IF;

      DB_VGL_DMTDC.Fkt7.I_REAL:= DWORD_TO_REAL(DB227.DBD[ziel]);
      Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=7);
      BCD_WORD_a:= DB_VGL_DMTDC.Fkt7.O_BCD;
      BCD_WORD_c:=BCD_WORD_a AND 2#1111000000000000;
      BCD_WORD_c:= SHR(IN:=BCD_WORD_c,n:=12);
      BCD_WORD_d:=WORD_TO_INT (BCD_WORD_c);
      IF (BCD_WORD_d > 0) AND (BCD_WORD_d < 9) THEN 
          BCD_WORD_b:=BCD_WORD_a;
      ELSE
          BCD_WORD_b:=BCD_WORD_a OR 2#1011000000000000;
      END_IF;    
      DB137.DBW[abByte]:= BCD_WORD_b; 
      GOTO FEND;


// (1bcd) <-- (2Byte)

F116:BCD_BYTE_d:=((DB227.DW[ziel]) AND 2#0000000001000111);

     DB_VGL_DMTDC.Fkt3.I_INT := (WORD_TO_INT (BCD_BYTE_d));
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=3);
     BCD_BYTE_1:= DB_VGL_DMTDC.Fkt3.O_BCD; //  DB137.DBW[abByte]
    
         
    
     BCD_BYTE_a:=(BCD_BYTE_1 AND 2#0000000011110000);
    
     BCD_BYTE_a:=(SHR(IN:=BCD_BYTE_a,n:=4));
     BCD_BYTE_c:=WORD_TO_INT(BCD_BYTE_a);
     IF (BCD_BYTE_c >0)AND(BCD_BYTE_c <9) THEN
        BCD_BYTE_b:=BCD_BYTE_1 ;
     ELSE    
        BCD_BYTE_b:=BCD_BYTE_1 OR 2#0000000010110000;
    END_IF;   
    
     DB137.DBB[abByte]:= WORD_TO_BYTE(BCD_BYTE_b); 
     GOTO FEND;

//3BYTE_BCD<--4BYTE_REAL
F117: DB_VGL_DMTDC.Fkt7.I_REAL:= DWORD_TO_REAL(DB227.DBD[ziel]);
      Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=7);
      BCD_WORD_x:= DB_VGL_DMTDC.Fkt7.O_BCD;
    //  BCD_WORD_y:=BCD_WORD_x AND 2#1111000000000000;
    //  BCD_WORD_y:= SHR(IN:=BCD_WORD_c,n:=12);
    //  BCD_WORD_z:=WORD_TO_INT (BCD_WORD_y);
    //  IF (BCD_WORD_z > 0) AND (BCD_WORD_z < 9) THEN 
    //      BCD_WORD_w:=BCD_WORD_x;
    //  ELSE
    //      BCD_WORD_w:=BCD_WORD_x OR 2#1011000000000000;
    //  END_IF;    
      DB137.DBB[abByte]:= 2#10110000; 
      DB137.DBW[abByte+1]:= BCD_WORD_x; 
      GOTO FEND;
//BCD (4Byte) --> Real (4Byte)
//00014747   entspricht Länge von 147.47
//Komma nach der 6.Stelle
//1.Stelle   0= positiver Wert
//10008640   entspricht Wert  -86.40
//Komma nach der 6.Stelle
//1.Stelle   1= minus Wert
F118:DB_VGL_DMTDC.Fkt9.I_REAL := (DWORD_TO_REAL(DB227.DBD[ziel]))*Faktor;
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=9);
     F18_BCD1 := DB_VGL_DMTDC.Fkt9.O_BCD;
     F18_BCD2:=F18_BCD1 AND 2#00011111111111111111111111111111; 

     DB137.DBD[abByte]:= F18_BCD2; 
 
  GOTO FEND;

//BCD (3Byte) --> Real (4Byte)
//000229     entspricht 0.229
//Komma nach der 3.Stelle
//100188     entspricht -0.188
//Komma nach der 3.Stelle
F119:DB_VGL_DMTDC.Fkt9.I_REAL := (DWORD_TO_REAL(DB227.DBD[ziel]))*Faktor;//Real wandeln in BCD
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=9);
     BCD_DWORD_14:= DB_VGL_DMTDC.Fkt9.O_BCD; 
     
     BCD_DWORD_113:=BCD_DWORD_14 AND 2#00010000000000000000000000000000;  //Vorzeichen auslesen 1=negativ; 0=positiv  
     BCD_DWORD_12:=BCD_DWORD_14 AND 2#00000000000011111111111111111111;  //Wert auslesen und nach links verschieben da vier anstatt drei Byte gelesen wurden
     BCD_DWORD_12:= SHL(IN:=BCD_DWORD_12,n:=8);
     BCD_DWORD_11:= BCD_DWORD_12 OR BCD_DWORD_113;  //Vorzeichen mit Wert zusammenfügen
     
     
     BCD_1Byte_a:= BCD_DWORD_12 AND 2#00000000000000001111111100000000;     //Hinteres Byte ausfilten 
     BCD_1Byte_b:= (DWORD_TO_WORD (SHR(IN:=BCD_1Byte_a,n:=8)));

     BCD_2Byte_a:= BCD_DWORD_11 AND 2#11111111111111110000000000000000;   //Vorderes Wort rausfiltern
     BCD_2Byte_b:= DWORD_TO_WORD (SHR(IN:=BCD_2Byte_a,n:=16));


     //DB137.DBW[abByte+1]:= BCD_1Byte_b;  //Hinteres BYTE schreiben
     DB137.DBD[abByte]:= BCD_DWORD_11;  //BCD_2Byte_b;   //die vorderern zwei Byte schreiben
  GOTO FEND;




   
F120:      //Low Bits aus Byte BCD --> 2Byte INT


      DB_VGL_DMTDC.Fkt3.I_INT := WORD_TO_INT(DB227.DW[ziel]);
      Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=3);
      BCD_F20_2:=WORD_TO_BYTE(DB_VGL_DMTDC.Fkt3.O_BCD);
              
      BCD_F20_1:= BCD_F20_save OR BCD_F20_2;
      DB137.DBB[abByte]:=BCD_F20_1;
   
 GOTO FEND;


//Geometrietypkonverierung / Reintjes
F121:   IF DWORD_TO_REAL(DB227.DBD[ziel]) = 200.0   THEN          //ChipGeoTyp 11 dann Bohrer 200
            DB137.DBB[abByte]:= 16#10;
            GOTO FEND;
        END_IF;
        IF DWORD_TO_REAL(DB227.DBD[ziel])  = 120.0  THEN  //ChipGeotyp 22/33 dann Fräser
             DB137.DBB[abByte] := 16#20 ;
            GOTO FEND;
        END_IF;   
            Error := TRUE;
            State := 1004;
        GOTO FEND;

//Geometrietypkonverierung / Geißlinger
F122: IF (index = ziel_Bit_Nr) THEN  //nur beim ersten Werkzeugtyp da sonst wenn nur eine Schneide vorhanden 
         IF (DWORD_TO_REAL(DB227.DBD[ziel]) = 200.0)   THEN          //ChipGeoTyp 10 dann Bohrer 200
             DB137.DBB[abByte]:= 16#10;
            GOTO FEND;
        END_IF;
        IF (DWORD_TO_REAL(DB227.DBD[ziel])  = 120.0)  THEN  //ChipGeotyp 20/30 dann Fräser
             DB137.DBB[abByte] := 16#20 ;
            GOTO FEND;
        END_IF;   
            Error := TRUE;
            State := 1004;
      END_IF;
 GOTO FEND;

F123:  s:=0;
       t:=0;
       u:=0;
       r:=0;
       gl:=0; 
       Gleitp:=false;
       Vorz:=false;
       DB_VGL_DMTDC.SchmiermDW:=0;
       v:= false;
       gl:=1;
       //STRING1[0]:=12;
       FOR j := 0 TO  12 BY 1 DO  //abnullen des Schmierbereichs
           DB229.dbb[154+j] := 0;       
       END_FOR;  
       FOR j := 0 TO  32 BY 1 DO  //abnullen des Schmierbereichs
           DB229.dbb[170+j] := 48;       
       END_FOR;  

 CASE ziel_Bit_Nr OF //UNTERFUNKTION
        1: CASE DWORD_TO_INT (DB227.DBW[ziel])OF
            1: DB_VGL_DMTDC.SchmiermDW:=1;
               GOTO x10;
            3: DB_VGL_DMTDC.SchmiermDW:=3;
               GOTO x10;
           ELSE
                Error := TRUE;
                State := 1006;
                GOTO FEND;
           END_CASE;    
           GOTO x10;
        2:  F23mw1:= DWORD_TO_WORD(DB227.DBW[ziel]) AND 2#0000000000000001;
            F23mw2:= DWORD_TO_WORD(DB227.DBW[ziel]) AND 2#0000000000000100;   
            IF WORD_TO_INT(F23mw1) > 0 THEN
                DB_VGL_DMTDC.SchmiermDW:=3;
                GOTO x10;
            ELSE
                IF  WORD_TO_INT(F23mw2) > 0 THEN
                    DB_VGL_DMTDC.SchmiermDW:=2;
                    GOTO x10;
                END_IF;
                DB_VGL_DMTDC.SchmiermDW:=1;
            END_IF;
            GOTO x10;
            //CASE DWORD_TO_INT(DB227.DBW[ziel])OF
            //2:DB_VGL_DMTDC.SchmiermDW:=1; //freigegeben
            //GOTO x10;
            //4:DB_VGL_DMTDC.SchmiermDW:=2; //gesperrt
            //GOTO x10;
            //16:DB_VGL_DMTDC.SchmiermDW:=3;//Vorwahrngrenze
            //GOTO x10;
            //END_CASE;
        3: IF (DWORD_TO_REAL(DB227.DBD[ziel])<>0.0) THEN
           IF DWORD_TO_REAL(DB227.DBD[ziel]) = 200.0   THEN          //ChipGeoTyp 10 dann Bohrer 200
              DB_VGL_DMTDC.SchmiermDW:=10;
              GOTO x10;
           END_IF;
           IF DWORD_TO_REAL(DB227.DBD[ziel])  = 120.0  THEN  //ChipGeotyp 20/30 dann Fräser
             DB_VGL_DMTDC.SchmiermDW:=20;
             GOTO x10;
           END_IF;   
            Error := TRUE;
            State := 1004;
            GOTO FEND;
         END_IF;
  END_CASE;
       
    IF (anzByte<=5) THEN
        DB_VGL_DMTDC.SchmiermDW:= DINT_TO_REAL(WORD_TO_DINT(DB227.DBw[ziel]));
    ELSE    
        DB_VGL_DMTDC.SchmiermDW:=DWORD_TO_REAL(DB227.DBD[ziel]);
    END_IF;
  
    
    IF (anzByte=12) THEN //Gleitpunktzahl
        DB_VGL_DMTDC.SchmiermDW:= (DWORD_TO_REAL(DB227.DBD[ziel]))*1000;
        gl:=0;  
    END_IF;    
    
 x10:   DB_VGL_DMTDC.SchmString:= DINT_TO_STRING(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW));
  
  
    IF (anzByte=12) THEN
         w:=BYTE_TO_INT(DB229.dbb[170+1]);  
         j:=0;
         FOR j:=0 TO w BY 1 DO
             db229.dbb[204+2+(8-w)+j]:=db229.dbb[170+3+j];
         END_FOR;
         j:=0;
         db229.dbb[204+2]:=db229.dbb[170+2];
         FOR j:=0 TO (8-w-2) BY 1 DO
             db229.dbb[204+3+j]:= 48;
         END_FOR;
         db229.dbb[205]:=7;
         j:=0;
         w:=BYTE_TO_INT(DB229.dbb[204+1]);
         FOR j:=j+gl TO w BY 1 DO 
            IF (j=4)AND(gl=0) THEN
            db137.dbb[abByte+(AnzByte-w)+j-1]:= 46;
            r:=1;
            ELSE
            db137.dbb[abByte+(AnzByte-w)+j-1+gl]:= DB229.dbb[204+2+j-r];
            END_IF;
         END_FOR;
         j:=0;
    ELSE
         j:=0;
         w:=BYTE_TO_INT(DB229.dbb[170+1]);
         FOR j:=j+gl TO w-1 BY 1 DO 
            IF (j=4)AND(gl=0) THEN
            db137.dbb[abByte+(AnzByte-w)+j-1]:= 46;
            r:=1;
            ELSE
            db137.dbb[abByte+(AnzByte-w)+j-1+gl]:= DB229.dbb[170+2+j-r];
            END_IF;
         END_FOR;
    END_IF;
               
          //j:=0;
         //IF (w=2)AND (gl=0) THEN
         //   w:=7;
         //END_IF; 
       GOTO FEND;
//4BYTE BCD --> REAL 4 Vorkaommastellen & 4 Nachkommastellen
F124:DB_VGL_DMTDC.Fkt9.I_REAL := (DWORD_TO_REAL(DB227.DBD[ziel]))*(Faktor/10);
     Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=9);
     BCD_DWORD_113:=DB_VGL_DMTDC.Fkt9.O_BCD;
     BCD_DWORD_113:=SHL(IN:=BCD_DWORD_113,n:=4);
     DB137.DBD[abByte]:=BCD_DWORD_113;
  GOTO FEND;

F125: GOTO FEND; 

// Bei Drehwerkzeugen die Länge1 und Länge2 vertauschen (Ruag)
F188: IF  (WORD_TO_INT(db137.dbw[ziel_Bit_Nr])>= 500)  AND (WORD_TO_INT(db137.dbw[ziel_Bit_Nr])<= 540) THEN
            u := 0;        
            FOR u:=0 TO (DWORD_TO_INT(DB227.DBW[22])) BY 1 DO //
              xx01 := DB137.DBD[abByte+(u*ziel)] ;
              xx02 := DB137.DBD[(abByte+(u*ziel))+AnzByte] ;
              DB137.DBD[(abByte+(u*ziel))+AnzByte] := xx01 ;
              DB137.DBD[abByte+(u*ziel)] := xx02 ;
            END_FOR;
      END_IF;
      GOTO FEND;
 
 
F189:GOTO FEND;
F190:GOTO FEND;
F191:GOTO FEND;
F192:GOTO FEND;
//2#10110000(B0)-->Byte
F193:DB137.DBB[abByte]:= 2#10110000;
GOTO FEND;
// 1 --> Bit
F194:GOTO FEND;
// 1 --> Word
F195:GOTO FEND; 
// 1 --> Byte
F196:GOTO FEND;     
// 0  --> Byte  
F197:DB137.DBB[abByte]:= 0; 
    GOTO FEND;
// 0  --> WORD  
F198:DB137.DBW[abByte]:= 0; 
    GOTO FEND;
// 0  --> WORD  
F199:DB137.DBD[abByte]:= 0; 
    GOTO FEND;

FEND:;   
END_FOR; 

IF bis >= Anz_Item THEN
   Done:=true;

END_IF;

GOTO BEND;


// --------------------------------------------

MODE3:


FOR n:=1 TO 2 BY 1 DO
        
    IF n=1 THEN
        m:=DB_KONFIG_DMTDC.Pos_Name;
    ELSE
        IF DB_KONFIG_DMTDC.Pos_Duplo <> 0 THEN
            m:=DB_KONFIG_DMTDC.Pos_Duplo;
        ELSE
            GOTO M3FEND;
        END_IF;
    END_IF;
    
    index       := db228.list[m].Item.index;
    abByte      := db228.list[m].Item.abByte;
    AnzByte     := db228.list[m].Item.AnzByte;
    Bit_Nr      := db228.list[m].Item.Bit_Nr;
    Funktion    := db228.list[m].Item.Funktion;
    ziel        := db228.list[m].Item.ziel;  
    ziel_Bit_Nr := db228.list[m].Item.ziel_Bit_Nr; 
    Faktor      := db228.list[m].Item.Faktor;


DB_VGL_DMTDC.Duplo:=0;
//DB_VGL_DMTDC.Text:=16#20;
 


    CASE Funktion OF
       1: GOTO M3F1;  // BCD (2Byte) --> INT (2Byte)
       2: GOTO M3F2;
       3: GOTO M3F3; //    (1Byte) --> (1Byte)     
       5: GOTO M3F5; //    STRING-> STRING
       6: GOTO M3F6; //    BCD--> STRING
      15: GOTO M3F15; //     2Byte BCD --> 4Byte Real 
      20: GOTO M3F20; //     2Byte BCD --> 4Byte Real 
      23: GOTO M3F23; //     2Byte BCD --> 4Byte Real 

    END_CASE;
    GOTO M3FEND; 


// Wandung von BCD (2Byte) nach INT
M3F1: DB_VGL_DMTDC.Fkt5.I_BCD_1 := DB137.DBW[abByte];
      Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=5);
      DB_VGL_DMTDC.Duplo := DINT_TO_INT(REAL_TO_DINT(DB_VGL_DMTDC.Fkt5.O_REAL)); 
      GOTO M3FEND;

// Int (2Byte) --> Int(2Byte)
M3F2: Erg_Int := WORD_TO_INT(DB137.DBW[abByte]);
     DB_VGL_DMTDC.Duplo := Erg_Int; 
      GOTO M3FEND;
      
// (1Byte) --> (1Byte)
M3F3:Erg_Byte :=(DB137.DBB[abByte]);           //Bei Duplonummer vgl mit funktion 3 wird vom chip 1Byte auf db227 2byte
     db229.dbb69 := Erg_Byte;                  //ins hintere db227Byte geschrieben und auch genauso in hintere Duplobyte vom db229 
     //DB_VGL_DMTDC.Duplo := Erg_Byte; 
     GOTO M3FEND;
      
      
// String[] --> String[32](Simatic)
//M3F5: DB229.DBB[text_pos] := 32;
//    DB229.DBB[(text_pos+1)] := WORD_TO_BYTE(INT_TO_WORD(AnzByte));
//    FOR j := 0 TO  (AnzByte-1) BY 1 DO
//         DB229.DBB[text_pos+j+2] := db137.dbb[abByte+j];
//    END_FOR;
//    GOTO M3FEND;


M3F5: DB229.DBB[text_pos] := 32;   

FOR j := 0 TO  18 BY 1 DO  //abnullen 
           DB229.dbb[text_pos+2+j] := 16#20;       
         END_FOR;  

    k:=0;
    FOR j := 0 TO  (AnzByte-1) BY 1 DO
        IF ((DB137.dbb[abByte+j] <> 16#20) AND (DB137.dbb[abByte+j] <> 16#00)) THEN
        
             DB229.dbb[text_pos+2+k] := db137.dbb[abByte+j];
             k:= k+1;
             END_IF;
             DB229.DBB[(text_pos+1)] := WORD_TO_BYTE(INT_TO_WORD(k));
    END_FOR;
    GOTO M3FEND;
    

M3F6: FOR j := 0 TO  AnzByte-1 BY 1 DO
         BCD_Byte    := db137.dbb[abByte+j];
         BCD_LOW     := BCD_Byte AND 2#00001111;
         BCD_LOW_AS  := BCD_LOW OR 2#00110000;
         BCD_High    := BCD_Byte AND 2#11110000;
         BCD_High    := SHR(IN:=BCD_High,n:=4);
         BCD_High_AS := BCD_High OR 2#00110000;
         DB229.dbb[text_pos+(j*2)+3] := BCD_LOW_AS;
         DB229.dbb[text_pos+(j*2)+2] := BCD_High_AS;       
      END_FOR;
      k:= 0;
      Null_found := FALSE;
      FOR j := 0  TO (AnzByte*2)-1 BY 1 DO
        IF DB229.dbb[text_pos+j+2] = 16#30 AND NOT Null_found THEN
            DB229.dbb[text_pos+j+2] := 16#20;
        ELSE
            DB229.dbb[text_pos+k+2] := DB229.dbb[text_pos+j+2];           
            Null_found := TRUE;
            k:=k+1;
        END_IF;
      END_FOR;
      DB229.DBB[text_pos] := 32;
      DB229.DBB[text_pos+1] := WORD_TO_BYTE(INT_TO_WORD(k));
      GOTO M3FEND;


//2BYTE_BCD-->4BYTE_REAL (Wenn auf Chip 0 dann Gleichziehen)
 M3F15:DB_VGL_DMTDC.Fkt5.I_BCD_1 := DB137.DBW[abByte];
       Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=5);
       DB_VGL_DMTDC.Duplo:= REAL_TO_INT(DB_VGL_DMTDC.Fkt5.O_REAL); 
       IF DB_VGL_DMTDC.Duplo = 0 THEN
          "DB_WZV_DV".Duplo_Nummer:=DB_VGL_DMTDC.Duplo;
       END_IF ;
       GOTO M3FEND;

 M3F20:BCD_DWORD_11 := DB137.DBD[abByte];
    BCD_DWORD_12:=BCD_DWORD_11 AND 2#00001111111111111111000000000000;
    
    BCD_DWORD_12:= SHR(IN:=BCD_DWORD_12,n:=12);
    BCD_DWORD_13:=DWORD_TO_WORD (BCD_DWORD_12);

    DB_VGL_DMTDC.Fkt1.I_BCD := BCD_DWORD_13;
    Erg_bool := FC_DMTDC_FUNKT(I_Fkt:=1);
    DB_VGL_DMTDC.Duplo:= (DB_VGL_DMTDC.Fkt1.O_INT); 
    GOTO M3FEND;

//ASCII[] TO REAL[4Byte] 
M3F23:s:=0;
    t:=0;
    u:=0;
    Gleitp:=false;
    Vorz:=false;
    DB_VGL_DMTDC.SchmiermDW:=0;
    v:= false;

    FOR j := 0 TO  12 BY 1 DO  //abnullen des Schmierbereichs
           DB229.dbb[154+j] := 0;       
         END_FOR;  
 
    FOR s:=0 TO (AnzByte-1) BY 1 DO
        IF (db137.dbb[abByte+s] <> 32) AND (db137.dbb[abByte+s] <> 48) AND (db137.dbb[abByte+s] <> 0) OR (v = true) THEN  //Wenn CHAR ist ungleich leer(32) od 0(48) 
            IF (db137.dbb[abByte+s] = 45)  OR (db137.dbb[abByte+s] = 43) THEN //Wenn CHAR ist +(43)/-(45)
               IF (db137.dbb[abByte+s] = 45) THEN
                   Vorz := true;
               END_IF;    
               GOTO MF23end;
            END_IF;
            IF (db137.dbb[abByte+s] = 46) THEN  // Dezimalpunkt
               Gleitp:=true;
               GOTO MF23end;
            END_IF;    
            IF ((BYTE_TO_INT(db137.dbb[abByte+s]) >= 48) AND (BYTE_TO_INT(db137.dbb[abByte+s]) <= 57)) THEN// THEN//Wenn keine Zahl dann Fehler
                DB229.dbb[154+t]:= (INT_TO_BYTE(BYTE_TO_INT(DB137.DBB[abByte+s])-48));//AUS ASCII INT
                t:= t+1;
                v:= true;
                db229.dbw170:=INT_TO_WORD(t);
            ELSE
                Error := TRUE;
                State := 1005;
            END_IF;
            MF23end: ;
        END_IF;
    END_FOR;       
          
    FOR u:=0 TO (t-1) BY 1 DO
       Merker:= INT_TO_REAL(BYTE_TO_INT(DB229.dbb[154+u]));//(EXPD(t-u));//+ DB_VGL_DMTDC.SchmiermDW); // (t-u)(INT_TO_DWORD
       Merker:= EXPD(t-u-1)*Merker;
       DB_VGL_DMTDC.SchmiermDW:= DINT_TO_REAL((REAL_TO_DINT (Merker)) + (REAL_TO_DINT (DB_VGL_DMTDC.SchmiermDW)) );
    END_FOR;

    DB_VGL_DMTDC.Duplo:=(DINT_TO_INT(REAL_TO_DINT(DB_VGL_DMTDC.SchmiermDW)));//DB_VGL_DMTDC.SchmiermDW;
 GOTO M3FEND;
M3FEND:; 
END_FOR;


IF  ("DB_WZV_DV".Wz_Bezeichner = DB_VGL_DMTDC.Text) THEN
    Vergleich := False;
ELSE    
    Vergleich := True;  
END_IF;    
 
IF  (Vergleich = True) THEN 
    GOTO a01; 
END_IF;
 
IF DB_KONFIG_DMTDC.Pos_Duplo <> 0 THEN  //Bei Geisliger steht keine Duplonummer auf dem Chip daher kann nicht verglichen werden!!

IF (DB_VGL_DMTDC.Duplo = "DB_WZV_DV".Duplo_Nummer) THEN
    Vergleich := False;
ELSE    
    Vergleich := True;
END_IF;    
END_IF;
a01:;
Done := True;
aktiv:= false;   

//------------------------------------------------
BEND:;
END_FUNCTION_BLOCK
