FUNCTION_BLOCK "FB_CI_H_DEKODER"
TITLE =
//$Revision: 1.16 $
//$Date: 2008/03/13 13:37:49CET $
//$Author: schmoelp $
//
//decode 2-3 digit M-codes
//Baustein übernommen vom M-Dekoder Böck Armin
//
//H-Funktion quittierbar
//zusätzlich wird für jede H-Funktion (0-99) der übergebene Wert im DB109 
//abgespeichert.
//Somit kann für jede H-Funktion der letzte übergebene Wert gelesen werden
//
//Ist die H-Funktion quittierpflichtig, so wird Einlesesperre gesetzt bis H-Fkt. 
//quittiert wird.
//
AUTHOR : Boeck
FAMILY : NC_DMG
NAME : M_Code
VERSION : 0.2
CODE_VERSION1


VAR_INPUT
  H_Change_Gr1 : BOOL ;	
  H_Change_Gr2 : BOOL ;	
  H_Change_Gr3 : BOOL ;	
  E_H_Function1 : INT ;	
  E_H_Function2 : INT ;	
  E_H_Function3 : INT ;	
  E_H_Wert_1 : REAL ;	
  E_H_Wert_2 : REAL ;	
  E_H_Wert_3 : REAL ;	
END_VAR
VAR_IN_OUT
  O_einlesesperre : BOOL ;	
  Fehler : BOOL ;	
END_VAR
VAR
  Hchange : BOOL ;	
  Hchange1 : BOOL ;	
  Hchange2 : BOOL ;	
  Hchange3 : BOOL ;	
  quittung_request : BOOL ;	
  H_Function1 : INT ;	
  H_Funktion2 : INT ;	
  H_funktion3 : INT ;	
  Warte_auf : INT ;	
  zeiger_Maske : DWORD ;	
  zeiger_Quittierfeld : DWORD ;	
  zeiger_ziel : DWORD ;	
  T_Point_Imp : DWORD ;	
  Change_IMP : ARRAY  [1 .. 3 ] OF BOOL ;	
  Point_Imp : ARRAY  [1 .. 3 ] OF DWORD ;	
END_VAR
VAR_TEMP
  HFunc : INT ;	
  HFuncGroup : DWORD ;	
  Group : INT ;	
  ByteAdr : INT ;	
  BitAdr : INT ;	
  Sindex : INT ;	
  HFuncint : INT ;	
  Startoffset : DWORD ;	
  Startoffset_quit : DWORD ;	
  Startoffset_Maske : DWORD ;	
  Offset_Wert_H_Fkt : DWORD ;	
  Hindex : INT ;	
  HWerteAdresse : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =Initialisierung

      U     "M_Reset_Taste"; 
      R     #Fehler; 
      R     #O_einlesesperre; 
      R     #quittung_request; 


      AUF   "DB_H_FUNKTION"; 

// Impulse Rücksetzen 

      U     #Change_IMP[1]; 
      SPBN  IR_1; 
      R     #Change_IMP[1]; 
      L     #Point_Imp[1]; 
      LAR1  ; 
      R     DBX [AR1,P#50.0]; // Quittierbit für die H-Funktion
IR_1: NOP   0; 

      U     #Change_IMP[2]; 
      SPBN  IR_2; 
      R     #Change_IMP[2]; 
      L     #Point_Imp[2]; 
      LAR1  ; 
      R     DBX [AR1,P#50.0]; // Quittierbit für die H-Funktion
IR_2: NOP   0; 

      U     #Change_IMP[3]; 
      SPBN  IR_3; 
      R     #Change_IMP[3]; 
      L     #Point_Imp[3]; 
      LAR1  ; 
      R     DBX [AR1,P#50.0]; // Quittierbit für die H-Funktion
IR_3: NOP   0; 

      UN    #H_Change_Gr1; 
      UN    #H_Change_Gr2; 
      UN    #H_Change_Gr3; 
      SPB   wart; //---neue A-Funktion von NC steht an
      CLR   ; 
      =     #Fehler; 
      L     0; 
      T     #Sindex; 
      U     #H_Change_Gr1; 
      =     #Hchange1; 


      U     #H_Change_Gr2; 
      =     #Hchange2; 
      U     #H_Change_Gr3; 
      =     #Hchange3; 


      L     #E_H_Function1; 
      T     #H_Function1; 

      L     #E_H_Function2; 
      T     #H_Funktion2; 
      L     #E_H_Function3; 
      T     #H_funktion3; 


      U     #Hchange1; 
      S     #Hchange; 

      L     #H_Function1; 
      T     #HFuncint; 
      L     0; 
      T     #Hindex; 

      SPA   deko; 

wart: NOP   0; //---warten auf Quittierung M-Funktion

      UN    #quittung_request; // warten auf Quittung
      SPB   _end; 
      L     #zeiger_Quittierfeld; 
      LAR1  ; 
      UN    DBX [AR1,P#0.0]; // Quittierbit für die M-Funktion
      SPB   _end; // warten auf Quittierbit
      R     DBX [AR1,P#0.0]; // Quittierbit für die M-Funktion
      L     #zeiger_ziel; 
      LAR1  ; 
      R     DBX [AR1,P#0.0]; // M-Funktionsmerker rücksetzen
      R     #O_einlesesperre; 
      R     #quittung_request; // warten auf Quittung
      SPA   LOOP; // weiter mit nächster M-Funktion

_end: BEA   ; 

NETWORK
TITLE =H-Funktionen auswerten und Ausgang setzen 
//M000-M399 -> db107.dbx0.0 - dbx49.7
//
deko: L     P#100.0; 
      T     #Startoffset_quit; 
      L     P#0.0; 
      T     #Startoffset; 

      L     200; 
      T     #Offset_Wert_H_Fkt; 


      L     #HFuncint; // H-Funktion
      T     #HFunc; 
      L     400; 
      <I    ; 
      SPB   F1; 
      SPA   Fehl; 

F1:   L     #HFunc; 
      L     8; 
      /I    ; 
      T     #ByteAdr; // Byte Adresse
      SRD   16; 
      T     #BitAdr; 

      L     #Startoffset; 
      L     #ByteAdr; 
      SLD   3; 
      +D    ; 
      L     #BitAdr; // Bit Adresse
      +D    ; 
      T     #zeiger_ziel; 


      L     #Offset_Wert_H_Fkt; 

      L     #ByteAdr; 
      L     8; 
      *I    ; 
      T     #HWerteAdresse; 
      L     #BitAdr; 
      +I    ; 
      T     #HWerteAdresse; 
      L     4; 
      *I    ; 
      T     #HWerteAdresse; 
      L     #Offset_Wert_H_Fkt; 
      +I    ; 
      T     #HWerteAdresse; 

      L     #HWerteAdresse; 
      SLD   3; 
      T     #HWerteAdresse; 
      LAR1  ; 

      L     #Hindex; // H-Indexwerte 0..2
      SPL   sple; 
      SPA   ind1; 
      SPA   ind2; 
      SPA   ind3; 
sple: SPA   ind0; 

ind0: L     0.000000e+000; 
      SPA   tind; 

ind1: L     #E_H_Wert_1; 
      SPA   tind; 

ind2: L     #E_H_Wert_2; 
      SPA   tind; 

ind3: L     #E_H_Wert_3; 
      SPA   tind; 

tind: T     DBD [AR1,P#0.0]; 

      L     #Startoffset_quit; 
      L     #ByteAdr; 
      SLD   3; 
      +D    ; 
      L     #BitAdr; // Bit Adresse
      +D    ; 
      T     #zeiger_Quittierfeld; 
      LAR1  ; 

      UN    DBX [AR1,P#50.0]; // Zeiger auf Maske 
      SPB   SETM; 
      L     #HFuncint; 
      T     #Warte_auf; 
      S     #quittung_request; 
      S     #O_einlesesperre; 



//---bis hier

      SPA   SETM; 

Fehl: S     #Fehler; 
      SPA   LOOP; 

// --- Ausgangsbit setzen ----

SETM: SET   ; 
      L     #zeiger_ziel; 
      LAR1  ; 
      S     DBX [AR1,P#0.0]; // Ausgang setzen
      S     DBX [AR1,P#50.0]; // impuls Ausgang setzen

      L     P##Change_IMP; //Zeiger auf Änderungsbit
      L     #Hindex; 
      +D    ; 
      LAR1  ; 
      S      [AR1,P#0.0]; 

      L     #Hindex; 
      L     4; 
      *I    ; 
      SLD   3; 
      L     P##Point_Imp; // Zeiger auf Änderungsvariable
      +D    ; 
      LAR1  ; 
      L     #zeiger_ziel; 
      T     D [AR1,P#0.0]; 

      U     #quittung_request; // Ende und warten auf quittung
      BEB   ; 


LOOP: U     #Hchange1; 
      R     #Hchange1; 

      UN    #Hchange2; 
      SPB   lop2; 
      R     #Hchange2; 
      L     #H_Funktion2; 
      T     #HFuncint; 
      L     1; 
      T     #Hindex; 
      SPA   deko; 

lop2: UN    #Hchange3; 
      SPB   lop3; 
      S     #Hchange; 
      R     #Hchange3; 
      L     #H_funktion3; 
      T     #HFuncint; 
      L     2; 
      T     #Hindex; 
      SPA   deko; 


lop3: BEA   ; 



      BEA   ; 
END_FUNCTION_BLOCK

