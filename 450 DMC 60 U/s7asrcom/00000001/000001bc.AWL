FUNCTION_BLOCK "FB_TM_WZTYP_RD"
TITLE =
//$Revision: 1.17 $
//$Date: 2008/08/06 17:28:17CEST $
//$Author: schmoelp $
//
//GET_LOC
//
//Inputs:
//- Req      Start des FB92
//- MagNr    Magazinnummer
//- Platz    Mode 0 aktiv -> Platznummer im Magazin
//           Mode 1 aktiv -> Anzahl der Plätze (3 oder 4) im Zwischenspeicher  
//- Mode     Mode 0 -> Es können aus allen Magazinen (Plätzen) Werkzeugdaten 
//           ausgelesen werden.
//           Mode 1 -> Auslesen der Zwischenspeicher (MagNr 9998)
//           Daten Spindel- und Greiferwerkzeug werden ausgelesen und
//           verglichen.
//
//Outputs:
//- NDR      Fertigmeldung des FB92
//- WZ_equal Werkzeugdaten (Grösse,variable Plätze) sind gleich
//- Error    Fehlerbit siehe State
//- Warning  nur Mode 1 beide Greifer leer oder belegt
//- State    Fehlercode 1-Fehler bei Lesen Magazindaten
//           2-Fehler bei Lesen Werkzeugdaten
//           4-nur Mode 1 Fehler bei Lesen Daten Greiferwerkzeug
//           8-interner Fehler FB92 
//
//Aufrufbeispiel FB92 nur Test:
//      U     "E___6.2" //Taste
//      UN    "M___1.1"
//      S     "M___1.0"
//
//      CALL  "FB__92" , "DB__62"
//       Req     :="M___1.0"
//       MagNr   :=9998
//       Platz_Nr:=1
//       Mode    :=1
//       NDR     :="M___1.1"
//       WZ_equal:="M___1.6"
//       Error   :="M___1.2"
//       Warning :="M___1.7"
//       State   :=MW250
//
//      O     "M___1.1"
//      O     "M___1.2"
//      R     "M___1.0"
//
//Hinweis:
//Aufruf des FB92 erfolgt im zyklischen Teil des PLC-Anwenderprogramms, wobei
//während des Aufrufs kein Datentausch der Werkzeugverwaltung erfolgen
//sollte (FC 8).
//V1.0 Absturz FB6, wenn FB92+FB91 gleichzeitig aufgerufen werden. Ursache unklar
//V1.1 Variable (NC_VAR) in Instanz-DB62 vereinbart
//
////28.02.2008 gs
////Feste Anzahl der Magazinplatzdaten(7) geäandert.
////Daten werden mit "M_numMagPlaceParam" berechnet.
////zZ ist der Wert 8
AUTHOR : ha
FAMILY : DMG
NAME : WZV_GET
VERSION : 1.1


VAR_INPUT
  Req : BOOL ;	// Start Zustände lesen
  B_Platz : INT ;	
  MagNr : INT ;	// Magazin-Nr. Daten lesen
  Platz : INT ;	// Platznummern oder Platzanzahl Daten lesen siehe Mode 0,1
  Velo_1 : REAL ;	
  Velo_2 : REAL ;	
  Velo_3 : REAL ;	
  Velo_4 : REAL ;	
  Velo_5 : REAL ;	
END_VAR
VAR_OUTPUT
  NDR : BOOL ;	// Daten gelesen  
  Error : BOOL ;	// Fehler
  Warning : BOOL ;	// Warnung
  State : WORD ;	// Fehler-Nummer
  SpWz_Typ : WORD ;	
  NewTool_Typ : WORD ;	
  SpWz_Velo : REAL ;	
  NewTool_Velo : REAL ;	
  SpWz_Reinigung : BOOL ;	
  SpWz_langsam : BOOL ;	
  NewTool_langsam : BOOL ;	
  SpWz_schnell : BOOL ;	
  NewTool_schnell : BOOL ;	
  NewTool_Siem_Typ : REAL ;	
END_VAR
VAR
  Req_old : BOOL ;	// Flankenhilfsmerker Start
  Req_PF : BOOL ;	// Flankenmerker Start
  Req_TNr : BOOL ;	// Eingang Req FB2 T-Nr. lesen
  Error_TNr : BOOL ;	// Ausgang Error FB2 T-Nr. lesen
  NDR_TNr : BOOL ;	// Ausgang NDR FB2 T-Nr. lesen
  Req_WZ : BOOL ;	// Eingang Req FB2 von WZ-Status lesen
  Error_WZ : BOOL ;	// Ausgang Error FB2 von WZ-Status lesen
  NDR_WZ : BOOL ;	// Ausgang NDR FB2 WZ-Status lesen
  Req_NewTool : BOOL ;	// Eingang Req FB2 von Greifer-Status lesen
  Error_NewTool : BOOL ;	// Ausgang Error FB2 von Greifer-Status lesen
  NDR_NewTool : BOOL ;	// Ausgang NDR FB2 Greifer-Status lesen
  FB2_OK : BOOL ;	// Magazindaten lesen ist abgeschlossen
  FB2a_OK : BOOL ;	// Werkzeugdaten lesen ist abgeschlossen
  FB2b_OK : BOOL ;	// Werkzeugdaten lesen ist abgeschlossen
  mod : BOOL ;	//0= Mode 0, 1= Mode 1
  WZ_equal_save : BOOL ;	//Werkzeugdaten Greifer/Spindel sind gleich
  T_Sp_leer : BOOL ;	//Spindel leer
  T_TPU_leer : BOOL ;	//Bereitstellungsplatz leer
  Res : BYTE ;	//Reserve
  LocNumVar : INT ;	//Anzahl zu lesende Daten
  Count : INT ;	//Zähler PLC-Zyklen nach Req bis NDR
  TNr_1 : INT ;	//logische T-Nummer Spindel
  Platzzustand_1 : INT ;	//Platzzustand Spindel
  Platzzustand_2 : INT ;	//Platzzustand neues Werkzeug
  TNr_2 : INT ;	//logische T-Nummer neues Werkzeug
  TNr_3 : INT ;	//logische T-Nummer Bereitstellungsplatz
  Groesse_links_1 : INT ;	//Größe nach links in Halbplätzen Spindel
  Groesse_rechts_1 : INT ;	//Größe nach rechts in Halbplätzen Spindel
  Groesse_links_2 : INT ;	//Größe nach links in Halbplätzen neues Werkzeug
  Groesse_rechts_2 : INT ;	//Größe nach rechts in Halbplätzen neues Werkzeug
  Groesse_links_3 : INT ;	//Größe nach links in Halbplätzen Bereitstellungsplatz
  Groesse_rechts_3 : INT ;	//Größe nach rechts in Halbplätzen Bereitstellungsplatz
  FB92_State : WORD ;	
  State_TNr : WORD ;	// Ausgang State FB2 T-Nr. lesen   
  State_TNr_save : WORD ;	// Ausgang State FB2 T-Nr. lesen gespeichert   
  State_WZ : WORD ;	// Ausgang State FB2 WZ-Status lesen  
  State_WZ_save : WORD ;	// Ausgang State FB2 WZ-Status lesen gespeichert  
  State_GR : WORD ;	// Ausgang State FB2 WZ-Status lesen  
  State_GR_save : WORD ;	// Ausgang State FB2 WZ-Status lesen gespeichert  
  LocSpalte_Spindel : WORD ;	// Spaltenadresse Magazin-Nr.
  LocSpalte_NewTool : WORD ;	
  LocLine1 : WORD ;	// Zeilenadresse 1 logische T-Nummer
  LocLine2 : WORD ;	// Zeilenadresse 1 Platzzustand
  LocLine3 : WORD ;	// Zeilenadresse 2 logische T-Nummer
  LocLine4 : WORD ;	// Zeilenadresse 2 Platzzustand
  LocLine5 : WORD ;	// Zeilenadresse 3 logische T-Nummer
  LocLine6 : WORD ;	// Zeilenadresse 3 Platzzustand
  LocLine7 : WORD ;	// Zeilenadresse 3 logische T-Nummer
  LocLine8 : WORD ;	// Zeilenadresse 3 Platzzustand
  WZLine_TPU : WORD ;	// Zeilenadresse allgemeine Werkzeugdaten
  WZLine_WZ : WORD ;	// Zeilenadresse allgemeine Werkzeugdaten
  WZLine_NewTool : WORD ;	// Zeilenadresse allgemeine Werkzeugdaten
  WZ_Maske : WORD  := W#16#40;	//Bit 6 festplatzcodiert
// Magazinplatzdaten (TP) FB92(T-Nummer)
  SpWZ_Long : REAL ;	
  NewTool_Long : REAL ;	
  Anz_Rd : INT ;	
  T1_TNR_Read : STRUCT 	
   SYNTAX_ID : BYTE  := B#16#82;	
   bereich_u_einheit : BYTE  := B#16#81;	
   spalte : WORD ;	
   zeile : WORD ;	
   bausteintyp : BYTE  := B#16#28;	
   ZEILENANZAHL : BYTE  := B#16#1;	
   typ : BYTE  := B#16#4;	
   laenge : BYTE  := B#16#2;	
  END_STRUCT ;	
  T1TP1_PlzuGET : STRUCT 	
   SYNTAX_ID : BYTE  := B#16#82;	
   bereich_u_einheit : BYTE  := B#16#81;	
   spalte : WORD ;	
   zeile : WORD ;	
   bausteintyp : BYTE  := B#16#28;	
   ZEILENANZAHL : BYTE  := B#16#1;	
   typ : BYTE  := B#16#4;	
   laenge : BYTE  := B#16#2;	
  END_STRUCT ;	// Allg.Werkzeugdaten (TD) FB92 (WZ-Grösse links)
  ToolOEMDATA : STRUCT 	
   SYNTAX_ID : BYTE  := B#16#82;	
   bereich_u_einheit : BYTE  := B#16#81;	
   spalte : WORD ;	
   zeile : WORD ;	
   bausteintyp : BYTE  := B#16#24;	
   ZEILENANZAHL : BYTE  := B#16#1;	
   typ : BYTE  := B#16#F;	
   laenge : BYTE  := B#16#8;	
  END_STRUCT ;	
  toolState_1T1TD8GET1 : STRUCT 	
   SYNTAX_ID : BYTE  := B#16#82;	
   bereich_u_einheit : BYTE  := B#16#81;	
   spalte : WORD ;	
   zeile : WORD ;	
   bausteintyp : BYTE  := B#16#21;	
   ZEILENANZAHL : BYTE  := B#16#1;	
   typ : BYTE  := B#16#4;	
   laenge : BYTE  := B#16#2;	
  END_STRUCT ;	// Allg.Werkzeugdaten (TD) FB92 (WZ-Grösse rechts)
  GET1_FB2 : "FB_SIEM_GET";	
  GET2_FB2 : "FB_SIEM_GET";	
  GET3_FB2 : "FB_SIEM_GET";	
  SpWZ_Status : INT ;	
  SpWZ_schwer : REAL ;	
  NewTool_schwer : REAL ;	
  SpWZ_Velo_Typ : REAL ;	
  NewTool_Velo_Typ : REAL ;	
  TPUWz_Status : INT ;	
  NewTool_KEGELR : REAL ;	
  SpWZ_Reinwert : REAL ;	
  New_Tool_SiemTyp : REAL ;	
  ToolSiemData : STRUCT 	
   SYNTAX_ID : BYTE  := B#16#82;	
   bereich_u_einheit : BYTE  := B#16#81;	
   spalte : WORD ;	
   zeile : WORD ;	
   bausteintyp : BYTE  := B#16#14;	
   ZEILENANZAHL : BYTE  := B#16#1;	
   typ : BYTE  := B#16#F;	
   laenge : BYTE  := B#16#8;	
  END_STRUCT ;	
END_VAR
VAR_TEMP
  WZStatus_2_temp : WORD ;	
  NewTool_Slong : BOOL ;	
  SpWZ_Slong : BOOL ;	
  GET2_NumVar : INT ;	
  GET3_NumVar : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =

      U     #Req; 
      FP    #Req_old; 
      =     #Req_PF; // Flanke Eingang Start
      UN    #Req; 
      R     #NDR; // Ausgangsparameter NDR nur 1 PLC-Zyklus        
      R     #Error; // Ausgangsparameter Error nur 1 PLC-Zyklus
      R     #Warning; 
      R     #Req_TNr; 
      R     #Req_WZ; 
      R     #Req_NewTool; 
      R     #FB2_OK; // Magazindaten lesen ist abgeschlossen 
      R     #FB2a_OK; // Werkzeugdaten lesen ist abgeschlossen
      R     #FB2b_OK; // Werkzeugdaten lesen ist abgeschlossen



NETWORK
TITLE =

      UN    #Req_PF; 
      SPB   anf; 
      L     0; 
      T     #State; // Fehler-Nr. = 0
      T     #Count; 
      SET   ; 
      R     #WZ_equal_save; //Werkzeugdaten Greifer/Spindel sind gleich
      R     #T_Sp_leer; 
      S     #Req_TNr; // TP-Daten Zwischenspeicher lesen
      L     9998; 
      T     #LocSpalte_Spindel; 
      L     1; 
      T     #LocLine1; 

      L     #MagNr; 
      T     #LocSpalte_NewTool; 
      L     #Platz; 
      T     #LocLine2; 


NETWORK
TITLE = Start Daten lesen

anf:  L     9998; 
      T     #LocSpalte_Spindel; 
      L     1; 
      L     1; 
      -I    ; 
      L     "MW_numMagPlaceParam"; // Berechnung der Zeilennummer:
      *I    ; // (PlatzNr.-1) * numMagPlaceParam + Parameter-Nr.  
      L     3; 
      +I    ; 
      T     #LocLine1; 

      L     #B_Platz; 
      L     1; 
      -I    ; 
      L     "MW_numMagPlaceParam"; // Berechnung der Zeilennummer:
      *I    ; // (PlatzNr.-1) * numMagPlaceParam + Parameter-Nr.  
      L     3; 
      +I    ; 
      T     #LocLine2; 

      NOP   0; 

      L     2; 
      T     #Anz_Rd; 

      CALL #GET1_FB2 (// ---- Magazinplatzdaten lesen --------------------------------
           Req                      := #Req_TNr,// Variable lesen
           NumVar                   := #Anz_Rd,// Anzahl der zu lesenden Variablen
           Addr1                    := #T1_TNR_Read,// logische T-Nummer 
           Column1                  := #LocSpalte_Spindel,// Spaltenadresse
           Line1                    := #LocLine1,// Zeilenadresse für log. T-Nr.
           Addr2                    := #T1_TNR_Read,
           Column2                  := #LocSpalte_Spindel,
           Line2                    := #LocLine2,
           Error                    := #Error_TNr,
           NDR                      := #NDR_TNr,
           State                    := #State_TNr,
           RD1                      := #TNr_1,
           RD2                      := #TNr_3);


      UN    #NDR_TNr; // Lesen beendet 
      UN    #Error_TNr; // Lesen beendet mit Fehler
      SPB   T0; //FB2a                        // Lesen beendet ? Nein ->
      R     #Req_TNr; // Anstoß lesen löschen
      UN    #Error_TNr; 
      S     #FB2_OK; // Magazindaten lesen ist abgeschlossen 
      SPB   T0; // Lesen beendet mit Fehler ? Nein ->
      L     #State_TNr; 
      T     #State_TNr_save; // Fehlernummer speichern
      L     1; // Fehler-Nummer FB 92 = 1
      SPA   err; 

T0:   NOP   0; 
      L     #TNr_1; // logische T-Nummer von WZ in Spindel 
      L     0; 
      ==I   ; 
      =     #T_Sp_leer; 

      L     #TNr_3; // logische T-Nummer von WZ in TPU 
      L     0; 
      ==I   ; 
      =     #T_TPU_leer; 

      O(    ; 
      L     "TMSpindleIF".IF[1].TLoc; //Kein Werkzeug in der Spindel
      L     0; 
      ==I   ; 
      )     ; 
      O(    ; //Werkzeug aus Zwischenspeicher entladen
      L     "TMSpindleIF".IF[1].NoBuff; //und Spindel ist leer
      L     1; 
      >I    ; 
      U     "TMSpindleIF".IF[1].T0; 
      )     ; 
      SPBN  FB2a; 
      S     #FB2a_OK; 
      L     1; //Bei T0 in Spindel Werkzeugdaten löschen 
      T     #Groesse_links_1; // Größe nach links in Halbplätzen
      T     #Groesse_rechts_1; // Größe nach rechts in Halbplätzen
      L     1.000000e+000; 
      T     #SpWZ_Long; 
      L     5.000000e+000; 
      T     #SpWZ_Velo_Typ; 
      L     0.000000e+000; 
      T     #SpWZ_schwer; 
      SPA   T0e; 

NETWORK
TITLE = Lesen Werkzeugdaten Spindel und TPU

FB2a: U     #FB2_OK; 
      S     #Req_WZ; 
      R     #Req_TNr; 
      L     #TNr_1; // logische T-Nr. = Zeilenadresse
      T     #WZLine_WZ; 
      L     #TNr_3; // logische T-Nr. = Zeilenadresse
      T     #WZLine_TPU; 

      U     #T_TPU_leer; 
      SPBN  TPUB; 

      L     0; 
      T     #Groesse_links_3; 
      T     #Groesse_rechts_1; 
      T     #TPUWz_Status; 

      L     5; 
      SPA   ENUM; 

TPUB: U     #T_Sp_leer; 
      SPB   SPLE; 
      L     8; 

ENUM: T     #GET2_NumVar; 

      CALL #GET2_FB2 (
           Req                      := #Req_WZ,// Variable WZ-Daten lesen
           NumVar                   := #GET2_NumVar,//8
           Addr1                    := #toolState_1T1TD8GET1,// Größe nach links in Halbplätze
           Column1                  := W#16#3,// Spaltenadresse
           Line1                    := #WZLine_WZ,// Zeilenadresse
           Addr2                    := #toolState_1T1TD8GET1,// Größe nach rechts in Halbplätze
           Column2                  := W#16#4,// Spaltenadresse
           Line2                    := #WZLine_WZ,// Zeilenadresse
           Addr3                    := #ToolOEMDATA,
           Column3                  := W#16#3,
           Line3                    := #WZLine_WZ,
           Addr4                    := #toolState_1T1TD8GET1,
           Column4                  := W#16#8,
           Line4                    := #WZLine_WZ,
           Addr5                    := #ToolOEMDATA,
           Column5                  := W#16#5,
           Line5                    := #WZLine_WZ,
           Addr6                    := #toolState_1T1TD8GET1,
           Column6                  := W#16#3,
           Line6                    := #WZLine_TPU,
           Addr7                    := #toolState_1T1TD8GET1,
           Column7                  := W#16#4,
           Line7                    := #WZLine_TPU,
           Addr8                    := #toolState_1T1TD8GET1,
           Column8                  := W#16#8,
           Line8                    := #WZLine_TPU,
           Error                    := #Error_WZ,
           NDR                      := #NDR_WZ,
           State                    := #State_WZ,
           RD1                      := #Groesse_links_1,// Größe nach links in Halbplätze
           RD2                      := #Groesse_rechts_1,// Größe nach rechts in Halbplätze
           RD3                      := #SpWZ_Long,// Werkzeuglänge 0=kurz, 1=lang
           RD4                      := #SpWZ_Status,
           RD5                      := #SpWZ_Velo_Typ,
           RD6                      := #Groesse_links_3,
           RD7                      := #Groesse_rechts_3,
           RD8                      := #TPUWz_Status);

      L     #SpWZ_Velo_Typ; 
      T     #SpWZ_schwer; 

      UN    #Error_WZ; 
      UN    #NDR_WZ; 
      SPB   FB2b; //  WZ-Daten lesen beendet ? nein ->
      R     #Req_WZ; 
      UN    #Error_WZ; 
      S     #FB2a_OK; 
      SPB   FB2b; // Lesen mit Fehler beendet ? Nein ->
      L     #State_WZ; 
      T     #State_WZ_save; // Fehler-Nr. FB2 speichern 
      L     2; // Fehler-Nr. FB92 = 2
      SPA   err; 

SPLE: L     3; 
      T     #GET2_NumVar; 

      CALL #GET2_FB2 (
           Req                      := #Req_WZ,// Variable WZ-Daten lesen
           NumVar                   := #GET2_NumVar,//8
           Addr1                    := #toolState_1T1TD8GET1,
           Column1                  := W#16#3,
           Line1                    := #WZLine_TPU,
           Addr2                    := #toolState_1T1TD8GET1,
           Column2                  := W#16#4,
           Line2                    := #WZLine_TPU,
           Addr3                    := #toolState_1T1TD8GET1,
           Column3                  := W#16#8,
           Line3                    := #WZLine_TPU,
           Error                    := #Error_WZ,
           NDR                      := #NDR_WZ,
           State                    := #State_WZ,
           RD1                      := #Groesse_links_3,
           RD2                      := #Groesse_rechts_3,
           RD3                      := #TPUWz_Status);

      UN    #Error_WZ; 
      UN    #NDR_WZ; 
      SPB   FB2b; //  WZ-Daten lesen beendet ? nein ->
      R     #Req_WZ; 
      UN    #Error_WZ; 
      S     #FB2a_OK; 
      SPB   FB2b; // Lesen mit Fehler beendet ? Nein ->
      L     #State_WZ; 
      T     #State_WZ_save; // Fehler-Nr. FB2 speichern 
      L     2; // Fehler-Nr. FB92 = 2
      SPA   err; 

NETWORK
TITLE = Lesen Werkzeugdaten neues Werkzeug

T0e:  NOP   0; 
//      L     0                           //Bei T0 in Spindel Werkzeugdaten löschen 
//      T     #Groesse_links_1            // Größe nach links in Halbplätzen
//      T     #Groesse_rechts_1           // Größe nach rechts in Halbplätzen

FB2b: L     "TMSpindleIF".IF[1].T_no; //#TNr_2
      L     0; 
      ==I   ; 
      SPBN  n5a; 
      S     #FB2b_OK; 
      L     1; 
      T     #Groesse_links_2; // Größe nach links in Halbplätzen
      T     #Groesse_rechts_2; // Größe nach rechts in Halbplätzen
      L     1.000000e+000; 
      T     #NewTool_Long; 
      L     5.000000e+000; 
      T     #NewTool_Velo_Typ; 
      L     0.000000e+000; 
      T     #NewTool_schwer; 
      SPA   ver; 

n5a:  L     "TMSpindleIF".IF[1].T_no; 
      T     #TNr_2; 
      T     #WZLine_NewTool; 
      U     #FB2_OK; 
      U     #FB2a_OK; 
      UN    #Warning; 
      S     #Req_NewTool; 
      R     #Req_WZ; 

      L     #TNr_1; 
      L     0; 
      ==I   ; 
      SPB   spl; 

      L     7; 
      SPA   get3; 

spl:  L     0; 
      T     #SpWZ_Reinwert; 

      L     6; 
get3: T     #GET3_NumVar; 

      CALL #GET3_FB2 (
           Req                      := #Req_NewTool,// Variable WZ-Daten lesen
           NumVar                   := #GET3_NumVar,
           Addr1                    := #toolState_1T1TD8GET1,// Größe nach links in Halbplätze
           Column1                  := W#16#3,// Spaltenadresse
           Line1                    := #WZLine_NewTool,// Zeilenadresse
           Addr2                    := #toolState_1T1TD8GET1,// Größe nach rechts in Halbplätze
           Column2                  := W#16#4,// Spaltenadresse
           Line2                    := #WZLine_NewTool,// Zeilenadresse
           Addr3                    := #ToolOEMDATA,
           Column3                  := W#16#3,
           Line3                    := #WZLine_NewTool,
           Addr4                    := #ToolOEMDATA,
           Column4                  := W#16#5,
           Line4                    := #WZLine_NewTool,
           Addr5                    := #ToolOEMDATA,
           Column5                  := W#16#6,
           Line5                    := #WZLine_NewTool,
           Addr6                    := #ToolSiemData,
           Column6                  := #WZLine_NewTool,
           Line6                    := W#16#1,
           Addr7                    := #ToolOEMDATA,
           Column7                  := W#16#6,
           Line7                    := #WZLine_WZ,
           Error                    := #Error_NewTool,
           NDR                      := #NDR_NewTool,
           State                    := #State_GR,
           RD1                      := #Groesse_links_2,// Größe nach links in Halbplätze
           RD2                      := #Groesse_rechts_2,// Größe nach rechts in Halbplätze
           RD3                      := #NewTool_Long,// Werkzeuglänge 0=kurz, 1=lang
           RD4                      := #NewTool_Velo_Typ,
           RD5                      := #NewTool_KEGELR,
           RD6                      := #New_Tool_SiemTyp,
           RD7                      := #SpWZ_Reinwert);

      L     #New_Tool_SiemTyp; 
      T     #NewTool_Siem_Typ; 

      L     #NewTool_Velo_Typ; 
      T     #NewTool_schwer; 

      UN    #Error_NewTool; 
      UN    #NDR_NewTool; 
      SPB   end1; //  WZ-Daten lesen beendet ? nein ->
      R     #Req_NewTool; 
      UN    #Error_NewTool; 
      S     #FB2b_OK; 
      SPB   ver; // Lesen mit Fehler beendet ? Nein ->
      L     #State_GR; 
      T     #State_GR_save; // Fehler-Nr. FB2 speichern 
      L     4; // Fehler-Nr. FB92 = 4
      SPA   err; 

NETWORK
TITLE = Vergleich Werkzeugdaten Greifer Spindel

ver:  U     #FB2a_OK; 
      U     #FB2b_OK; 
      UN    #Warning; 
      SPBN  end; //Aufträge Werkzeugdaten lesen noch nicht OK
      L     #SpWZ_Reinwert; 
      L     0.000000e+000; 
      <>R   ; 
      =     #SpWz_Reinigung; 
      SPA   end; 
NETWORK
TITLE = Ende Werkzeugdaten lesen
//warn: SET   
//      S     #Warning
//      SPA   end1
      U     #FB2_OK; 
      SPB   end2; 
      SPA   end; 

end1: NOP   0; 
//      U     #FB2_OK
//      U     #FB2a_OK                    // Lesen Werkzeugdaten OK
//      U(    
//      ON    #mod                        // Mode 0
//      O     #FB2b_OK                    // Lesen Greiferdaten OK
//      O     #Warning
//      )     
end2: NOP   0; 
//     S     #NDR

end:  U     #FB2a_OK; 
      U     #FB2b_OK; 
      UN    #Warning; 
      S     #NDR; //Auftrag erledigt   

      L     #Count; 
      L     50; 
      >I    ; // Abbruch bei mehr als 30 PLC-Zyklen
      U     #Req; 
      SPBN  end3; 
      L     8; // Fehlernr 8
err:  T     #State; // Fehler-Nummer FB92 ausgeben
      S     #Error; 
      S     #NDR; 
      BEA   ; 

end3: NOP   0; 

//Auswertung Typ für Spindelwerkzeug
      U     "M_WZM_Regal_angewaehlt"; 
      SPB   reg1; 

      L     #SpWZ_Long; 
      L     2.000000e+000; // 0: lang, 1: kurz, 2: saulang
      ==R   ; 
      =     #SpWZ_Slong; 
      SPB   nueb; 

      L     #SpWZ_Long; 
      L     0.000000e+000; // 0: lang, 1: kurz
      ==R   ; 
      SPB   lang; 
      L     #Groesse_links_1; 
      L     #Groesse_rechts_1; 
      >=I   ; 
      SPB   nw7a; 
      L     #Groesse_rechts_1; 
      L     1; 
      >I    ; 
      SPB   nw7b; 
      L     1; 
      SPA   auku; 

nw7b: TAK   ; 
      L     2; 
      >I    ; 
      SPB   nw7c; 
      L     2; 
      SPA   auku; 

nw7c: TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     3; 
      SPA   auku; 

nw7a: TAK   ; 
      L     1; 
      >I    ; 
      SPB   nw7d; 
      L     1; 
      SPA   auku; 

nw7d: TAK   ; 
      L     2; 
      >I    ; 
      SPB   nw7e; 
      L     2; 
      SPA   auku; 

nw7e: TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     3; 
      SPA   auku; 

lang: L     #Groesse_links_1; 
      L     #Groesse_rechts_1; 
      >=I   ; 
      SPB   nw7f; 
      L     #Groesse_rechts_1; 
      L     1; 
      >I    ; 
      SPB   nw7g; 

// bei groesse 1 links/rechts --> überlang checken --> ja: Typ 5

      L     6; 
      SPA   auku; 

nueb: L     7; 
      SPA   auku; 

nw7g: TAK   ; 
      L     2; 
      >I    ; 
      SPB   nw7h; 
      L     5; 
      SPA   auku; 

nw7h: TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     4; 
      SPA   auku; 

nw7f: TAK   ; 
      L     1; 
      >I    ; 
      SPB   nw7i; 
      L     6; 
      SPA   auku; 

nw7i: TAK   ; 
      L     2; 
      >I    ; 
      SPB   nw7j; 
      L     5; 
      SPA   auku; 

nw7j: TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     4; 

auku: T     #SpWz_Typ; 


//Auswertung Typ für neues Werkzeug

      L     #NewTool_Long; 
      L     2.000000e+000; 
      ==R   ; // 0: lang 1:kurz
      =     #NewTool_Slong; 
      SPB   nue2; 

      L     #NewTool_Long; 
      L     0.000000e+000; 
      ==R   ; // 0: lang 1:kurz
      SPB   lan1; 

      L     #Groesse_links_2; 
      L     #Groesse_rechts_2; 
      >=I   ; 
      SPB   n7a; 
      L     #Groesse_rechts_2; 
      L     1; 
      >I    ; 
      SPB   n7b; 
      L     1; 
      SPA   aune; 

n7b:  TAK   ; 
      L     2; 
      >I    ; 
      SPB   n7c; 
      L     2; 
      SPA   aune; 

n7c:  TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     3; 
      SPA   aune; 

n7a:  TAK   ; 
      L     1; 
      >I    ; 
      SPB   n7d; 
      L     1; 
      SPA   aune; 

n7d:  TAK   ; 
      L     2; 
      >I    ; 
      SPB   n7e; 
      L     2; 
      SPA   aune; 

n7e:  TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     3; 
      SPA   aune; 

lan1: L     #Groesse_links_2; 
      L     #Groesse_rechts_2; 
      >=I   ; 
      SPB   n7f; 
      L     #Groesse_rechts_2; 
      L     1; 
      >I    ; 
      SPB   n7g; 
      L     6; 
      SPA   aune; 

n7g:  TAK   ; 
      L     2; 
      >I    ; 
      SPB   n7h; 
      L     5; 
      SPA   aune; 

n7h:  TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     4; 
      SPA   aune; 

n7f:  TAK   ; 
      L     1; 
      >I    ; 
      SPB   n7i; 

      L     6; 
      SPA   aune; 

nue2: L     7; 
      SPA   aune; 

n7i:  TAK   ; 
      L     2; 
      >I    ; 
      SPB   n7j; 
      L     5; 
      SPA   aune; 

n7j:  TAK   ; 
      L     4; 
      >I    ; 
      SPB   err1; 
      L     4; 

aune: T     #NewTool_Typ; 
      SPA   nw7k; 

reg1: L     #SpWZ_Long; 
      RND   ; 
      T     #SpWz_Typ; 

      L     #NewTool_Long; 
      RND   ; 
      T     #NewTool_Typ; 

nw7k: L     #SpWZ_schwer; 
      L     1.000000e+000; 
      ==R   ; 
      =     #SpWz_langsam; 

      L     #SpWZ_schwer; 
      L     2.000000e+000; 
      ==R   ; 
      =     #SpWz_schnell; 

      L     #NewTool_schwer; 
      L     1.000000e+000; 
      ==R   ; 
      =     #NewTool_langsam; 

      L     #NewTool_schwer; 
      L     2.000000e+000; 
      ==R   ; 
      =     #NewTool_schnell; 

//Auswertung Greifergeschwindigkeit
      L     #SpWZ_Velo_Typ; 
      L     0.000000e+000; 
      ==R   ; 
      SPBN  ves1; 
      L     #SpWz_Typ; 
      L     6; 
      >I    ; 
      SPB   vss1; 
      L     #Velo_4; 
      T     #SpWz_Velo; 
      SPA   ven0; 
vss1: L     #Velo_3; 
      T     #SpWz_Velo; 
      SPA   ven0; 

ves1: L     #SpWZ_Velo_Typ; 
      L     1.000000e+000; 
      ==R   ; 
      SPBN  ves2; 
      L     #Velo_2; 
      T     #SpWz_Velo; 
      SPA   ven0; 

ves2: L     #SpWZ_Velo_Typ; 
      L     2.000000e+000; 
      ==R   ; 
      SPBN  ves3; 
      L     #Velo_2; 
      T     #SpWz_Velo; 
      SPA   ven0; 

ves3: L     #SpWZ_Velo_Typ; 
      L     3.000000e+000; 
      ==R   ; 
      SPBN  ves4; 
      L     #Velo_3; 
      T     #SpWz_Velo; 
      SPA   ven0; 

ves4: L     #SpWZ_Velo_Typ; 
      L     4.000000e+000; 
      ==R   ; 
      SPBN  ves5; 
      L     #Velo_4; 
      T     #SpWz_Velo; 
      SPA   ven0; 

ves5: L     #SpWZ_Velo_Typ; 
      L     5.000000e+000; 
      ==R   ; 
      SPBN  ven0; 
      L     #Velo_5; 
      T     #SpWz_Velo; 
      SPA   ven0; 


ven0: L     #NewTool_Velo_Typ; 
      L     0.000000e+000; 
      ==R   ; 
      SPBN  ven1; 
      L     #NewTool_Typ; 
      L     6; 
      >I    ; 
      SPB   vsn1; 
      L     #Velo_4; 
      T     #NewTool_Velo; 
      SPA   vele; 
vsn1: L     #Velo_3; 
      T     #NewTool_Velo; 
      SPA   vele; 

ven1: L     #NewTool_Velo_Typ; 
      L     1.000000e+000; 
      ==R   ; 
      SPBN  ven2; 
      L     #Velo_2; 
      T     #NewTool_Velo; 
      SPA   vele; 

ven2: L     #NewTool_Velo_Typ; 
      L     2.000000e+000; 
      ==R   ; 
      SPBN  ven3; 
      L     #Velo_2; 
      T     #NewTool_Velo; 
      SPA   vele; 

ven3: L     #NewTool_Velo_Typ; 
      L     3.000000e+000; 
      ==R   ; 
      SPBN  ven4; 
      L     #Velo_3; 
      T     #NewTool_Velo; 
      SPA   vele; 

ven4: L     #NewTool_Velo_Typ; 
      L     4.000000e+000; 
      ==R   ; 
      SPBN  ven5; 
      L     #Velo_4; 
      T     #NewTool_Velo; 
      SPA   vele; 

ven5: L     #NewTool_Velo_Typ; 
      L     5.000000e+000; 
      ==R   ; 
      SPBN  vele; 
      L     #Velo_5; 
      T     #NewTool_Velo; 
      SPA   vele; 

vele: U     #FB2a_OK; 
      U     #FB2b_OK; 
      UN    #Warning; 
      S     #NDR; //Auftrag erledigt   
err1: NOP   0; 

      UN    #Req; 
      BEB   ; 

      L     #Count; 
      INC   1; 
      T     #Count; //Schreiben Anzahl PLC-Zyklen 

      NOP   0; 
END_FUNCTION_BLOCK

